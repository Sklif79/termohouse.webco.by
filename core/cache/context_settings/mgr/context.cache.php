<?php  return array (
  'config' => 
  array (
    'allow_tags_in_post' => '1',
    'modRequest.class' => 'modManagerRequest',
  ),
  'aliasMap' => 
  array (
  ),
  'webLinkMap' => 
  array (
  ),
  'eventMap' => 
  array (
    'msOnBeforeAddToCart' => 
    array (
      47 => '47',
    ),
    'msOnBeforeAddToOrder' => 
    array (
      15 => '15',
    ),
    'msOnBeforeChangeInCart' => 
    array (
      47 => '47',
    ),
    'msOnBeforeCreateOrder' => 
    array (
      51 => '51',
    ),
    'msOnBeforeCreateOrderProduct' => 
    array (
      47 => '47',
    ),
    'msOnBeforeRemoveOrderProduct' => 
    array (
      47 => '47',
    ),
    'msOnBeforeUpdateOrderProduct' => 
    array (
      47 => '47',
    ),
    'msOnChangeOrderStatus' => 
    array (
      14 => '14',
      47 => '47',
      15 => '15',
    ),
    'msOnCreateOrder' => 
    array (
      52 => '52',
      15 => '15',
    ),
    'msOnGetOrderCost' => 
    array (
      15 => '15',
    ),
    'msOnGetProductPrice' => 
    array (
      15 => '15',
      47 => '47',
    ),
    'msOnGetProductWeight' => 
    array (
      47 => '47',
    ),
    'msOnManagerCustomCssJs' => 
    array (
      51 => '51',
      52 => '52',
    ),
    'msOnRemoveOrder' => 
    array (
      47 => '47',
    ),
    'msOnSaveOrder' => 
    array (
      47 => '47',
    ),
    'OnBeforeDocFormSave' => 
    array (
      5 => '5',
      25 => '25',
    ),
    'OnBeforeEmptyTrash' => 
    array (
      5 => '5',
    ),
    'OnCacheUpdate' => 
    array (
      30 => '30',
    ),
    'OnChunkFormPrerender' => 
    array (
      37 => '37',
      36 => '36',
      1 => '1',
    ),
    'OnChunkFormSave' => 
    array (
      36 => '36',
      37 => '37',
    ),
    'OnDocFormPrerender' => 
    array (
      1 => '1',
      25 => '25',
      7 => '7',
      37 => '37',
      5 => '5',
      36 => '36',
      47 => '47',
    ),
    'OnDocFormRender' => 
    array (
      2 => '2',
      24 => '24',
      5 => '5',
    ),
    'OnDocFormSave' => 
    array (
      25 => '25',
      37 => '37',
      36 => '36',
      24 => '24',
      16 => '16',
      47 => '47',
    ),
    'OnEmptyTrash' => 
    array (
      25 => '25',
      47 => '47',
    ),
    'OnFileCreateFormPrerender' => 
    array (
      1 => '1',
    ),
    'OnFileEditFormPrerender' => 
    array (
      1 => '1',
    ),
    'OnFileManagerUpload' => 
    array (
      38 => '38',
      9 => '9',
    ),
    'OnHandleRequest' => 
    array (
      18 => '18',
      14 => '14',
      20 => '20',
    ),
    'OnLoadWebDocument' => 
    array (
      19 => '19',
      15 => '15',
      14 => '14',
      25 => '25',
      24 => '24',
    ),
    'OnManagerPageBeforeRender' => 
    array (
      5 => '5',
      17 => '17',
      1 => '1',
      25 => '25',
      18 => '18',
      28 => '28',
      6 => '6',
    ),
    'OnManagerPageInit' => 
    array (
      5 => '5',
      31 => '31',
      22 => '22',
    ),
    'OnMODXInit' => 
    array (
      11 => '11',
      14 => '14',
      52 => '52',
      4 => '4',
      48 => '48',
    ),
    'OnPageNotFound' => 
    array (
      25 => '25',
    ),
    'OnPluginFormPrerender' => 
    array (
      1 => '1',
      37 => '37',
    ),
    'OnPluginFormSave' => 
    array (
      37 => '37',
    ),
    'OnResourceBeforeSort' => 
    array (
      5 => '5',
      25 => '25',
    ),
    'OnResourceDelete' => 
    array (
      16 => '16',
    ),
    'OnResourceDuplicate' => 
    array (
      25 => '25',
      24 => '24',
      47 => '47',
    ),
    'OnResourceUndelete' => 
    array (
      16 => '16',
    ),
    'OnRichTextBrowserInit' => 
    array (
      35 => '35',
      33 => '33',
      28 => '28',
    ),
    'OnRichTextEditorInit' => 
    array (
      35 => '35',
      33 => '33',
      28 => '28',
    ),
    'OnRichTextEditorRegister' => 
    array (
      1 => '1',
      35 => '35',
      33 => '33',
      28 => '28',
    ),
    'OnSiteRefresh' => 
    array (
      11 => '11',
      10 => '10',
      12 => '12',
    ),
    'OnSnipFormPrerender' => 
    array (
      36 => '36',
      1 => '1',
      37 => '37',
    ),
    'OnSnipFormSave' => 
    array (
      37 => '37',
    ),
    'OnTempFormPrerender' => 
    array (
      37 => '37',
      36 => '36',
      1 => '1',
    ),
    'OnTempFormSave' => 
    array (
      37 => '37',
      36 => '36',
    ),
    'OnTVFormPrerender' => 
    array (
      37 => '37',
    ),
    'OnTVFormSave' => 
    array (
      37 => '37',
    ),
    'OnTVInputPropertiesList' => 
    array (
      7 => '7',
    ),
    'OnTVInputRenderList' => 
    array (
      7 => '7',
    ),
    'OnUpdaterCoreRefresh' => 
    array (
      32 => '32',
    ),
    'OnUpdaterNotify' => 
    array (
      29 => '29',
    ),
    'OnUpdaterPackagesRefresh' => 
    array (
      32 => '32',
    ),
    'OnUserSave' => 
    array (
      14 => '14',
      20 => '20',
    ),
    'OnWebPageInit' => 
    array (
      31 => '31',
      14 => '14',
    ),
    'OnWebPagePrerender' => 
    array (
      11 => '11',
      23 => '23',
      10 => '10',
    ),
  ),
  'pluginCache' => 
  array (
    1 => 
    array (
      'id' => '1',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'Ace',
      'description' => 'Ace code editor plugin for MODx Revolution',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => '/**
 * Ace Source Editor Plugin
 *
 * Events: OnManagerPageBeforeRender, OnRichTextEditorRegister, OnSnipFormPrerender,
 * OnTempFormPrerender, OnChunkFormPrerender, OnPluginFormPrerender,
 * OnFileCreateFormPrerender, OnFileEditFormPrerender, OnDocFormPrerender
 *
 * @author Danil Kostin <danya.postfactum(at)gmail.com>
 *
 * @package ace
 *
 * @var array $scriptProperties
 * @var Ace $ace
 */
if ($modx->event->name == \'OnRichTextEditorRegister\') {
    $modx->event->output(\'Ace\');
    return;
}

if ($modx->getOption(\'which_element_editor\', null, \'Ace\') !== \'Ace\') {
    return;
}

$ace = $modx->getService(\'ace\', \'Ace\', $modx->getOption(\'ace.core_path\', null, $modx->getOption(\'core_path\').\'components/ace/\').\'model/ace/\');
$ace->initialize();

$extensionMap = array(
    \'tpl\'   => \'text/x-smarty\',
    \'htm\'   => \'text/html\',
    \'html\'  => \'text/html\',
    \'css\'   => \'text/css\',
    \'scss\'  => \'text/x-scss\',
    \'less\'  => \'text/x-less\',
    \'svg\'   => \'image/svg+xml\',
    \'xml\'   => \'application/xml\',
    \'xsl\'   => \'application/xml\',
    \'js\'    => \'application/javascript\',
    \'json\'  => \'application/json\',
    \'php\'   => \'application/x-php\',
    \'sql\'   => \'text/x-sql\',
    \'md\'    => \'text/x-markdown\',
    \'txt\'   => \'text/plain\',
    \'twig\'  => \'text/x-twig\'
);

// Define default mime for html elements(templates, chunks and html resources)
$html_elements_mime=$modx->getOption(\'ace.html_elements_mime\',null,false);
if(!$html_elements_mime){
    // this may deprecated in future because components may set ace.html_elements_mime option now
    switch (true) {
        case $modx->getOption(\'twiggy_class\'):
            $html_elements_mime = \'text/x-twig\';
            break;
        case $modx->getOption(\'pdotools_fenom_parser\'):
            $html_elements_mime = \'text/x-smarty\';
            break;
        default:
            $html_elements_mime = \'text/html\';
    }
}

// Defines wether we should highlight modx tags
$modxTags = false;
switch ($modx->event->name) {
    case \'OnSnipFormPrerender\':
        $field = \'modx-snippet-snippet\';
        $mimeType = \'application/x-php\';
        break;
    case \'OnTempFormPrerender\':
        $field = \'modx-template-content\';
        $modxTags = true;
        $mimeType = $html_elements_mime;
        break;
    case \'OnChunkFormPrerender\':
        $field = \'modx-chunk-snippet\';
        if ($modx->controller->chunk && $modx->controller->chunk->isStatic()) {
            $extension = pathinfo($modx->controller->chunk->name, PATHINFO_EXTENSION);
            if(!$extension||!isset($extensionMap[$extension])){
                $extension = pathinfo($modx->controller->chunk->getSourceFile(), PATHINFO_EXTENSION);
            }
            $mimeType = isset($extensionMap[$extension]) ? $extensionMap[$extension] : \'text/plain\';
        } else {
            $mimeType = $html_elements_mime;
        }
        $modxTags = true;
        break;
    case \'OnPluginFormPrerender\':
        $field = \'modx-plugin-plugincode\';
        $mimeType = \'application/x-php\';
        break;
    case \'OnFileCreateFormPrerender\':
        $field = \'modx-file-content\';
        $mimeType = \'text/plain\';
        break;
    case \'OnFileEditFormPrerender\':
        $field = \'modx-file-content\';
        $extension = pathinfo($scriptProperties[\'file\'], PATHINFO_EXTENSION);
        $mimeType = isset($extensionMap[$extension])
            ? $extensionMap[$extension]
            : \'text/plain\';
        $modxTags = $extension == \'tpl\';
        break;
    case \'OnDocFormPrerender\':
        if (!$modx->controller->resourceArray) {
            return;
        }
        $field = \'ta\';
        $mimeType = $modx->getObject(\'modContentType\', $modx->controller->resourceArray[\'content_type\'])->get(\'mime_type\');

        if($mimeType == \'text/html\')$mimeType = $html_elements_mime;

        if ($modx->getOption(\'use_editor\')){
            $richText = $modx->controller->resourceArray[\'richtext\'];
            $classKey = $modx->controller->resourceArray[\'class_key\'];
            if ($richText || in_array($classKey, array(\'modStaticResource\',\'modSymLink\',\'modWebLink\',\'modXMLRPCResource\'))) {
                $field = false;
            }
        }
        $modxTags = true;
        break;
    default:
        return;
}

$modxTags = (int) $modxTags;
$script = \'\';
if ($field) {
    $script .= "MODx.ux.Ace.replaceComponent(\'$field\', \'$mimeType\', $modxTags);";
}

if ($modx->event->name == \'OnDocFormPrerender\' && !$modx->getOption(\'use_editor\')) {
    $script .= "MODx.ux.Ace.replaceTextAreas(Ext.query(\'.modx-richtext\'));";
}

if ($script) {
    $modx->controller->addHtml(\'<script>Ext.onReady(function() {\' . $script . \'});</script>\');
}',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'ace/elements/plugins/ace.plugin.php',
    ),
    36 => 
    array (
      'id' => '36',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'modDevTools',
      'description' => '',
      'editor_type' => '0',
      'category' => '38',
      'cache_type' => '0',
      'plugincode' => '/**
 * modDevTools
 *
 * Copyright 2014 by Vitaly Kireev <kireevvit@gmail.com>
 *
 * @package moddevtools
 *
 * @var modX $modx
 * @var int $id
 * @var string $mode
 */

/**
 * @var modx $modx
 */
$path = $modx->getOption(\'moddevtools_core_path\',null,$modx->getOption(\'core_path\').\'components/moddevtools/\').\'model/moddevtools/\';
/**
 * @var modDevTools $devTools
 */
$devTools = $modx->getService(\'devTools\',\'modDevTools\',$path, array(\'debug\' => false));
$eventName = $modx->event->name;

switch($eventName) {
    case \'OnDocFormSave\':
        $devTools->debug(\'Start OnDocFormSave\');
        $devTools->parseContent($resource);
        break;
    case \'OnTempFormSave\':
        $devTools->debug(\'Start OnTempFormSave\');
        $devTools->parseContent($template);
        break;
    case \'OnTVFormSave\':

        break;
    case \'OnChunkFormSave\':
        $devTools->debug(\'Start OnChunkFormSave\');
        $devTools->parseContent($chunk);
        break;
    case \'OnSnipFormSave\':

        break;
    /* Add tabs */
    case \'OnDocFormPrerender\':
        if ($modx->event->name == \'OnDocFormPrerender\') {
            $devTools->getBreadCrumbs($scriptProperties);
            return;
        }
        break;

    case \'OnTempFormPrerender\':
        if ($mode == modSystemEvent::MODE_UPD) {
            $result = $devTools->outputTab(\'Template\');
        }
        break;

    case \'OnTVFormPrerender\':
        break;


    case \'OnChunkFormPrerender\':
        if ($mode == modSystemEvent::MODE_UPD) {
            $result = $devTools->outputTab(\'Chunk\');
        }
        break;

    case \'OnSnipFormPrerender\':
        if ($mode == modSystemEvent::MODE_UPD) {
            $result = $devTools->outputTab(\'Snippet\');
        }
        break;


}

if (isset($result) && $result === true)
    return;
elseif (isset($result)) {
    $modx->log(modX::LOG_LEVEL_ERROR,\'[modDevTools] An error occured. Event: \'.$eventName.\' - Error: \'.($result === false) ? \'undefined error\' : $result);
    return;
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/moddevtools/elements/plugins/plugin.moddevtools.php',
    ),
    2 => 
    array (
      'id' => '2',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'AutoTemplate',
      'description' => 'Set the template of a new resource automatically to the one it\'s siblings have or, if it has no siblings, to the one it\'s parent has.',
      'editor_type' => '0',
      'category' => '4',
      'cache_type' => '0',
      'plugincode' => '/**
 * AutoTemplate for MODx Revolution
 *
 * This plugin sets a new document\'s template automatically to the one it\'s siblings
 * have or, if it has no siblings, to the one it\'s parent has.
 *
 * AutoTemplate is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * AutoTemplate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Inherit Template; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * @author      Maarten     <@maarten>
 * @copyright   Copyright (c) 2009, Magnatron
 * @license     GPL v2
 *
 * @package     AutoTemplate
 * @subpackage  plugin
 */


if ($modx->event->name === \'OnDocFormRender\') {
	
	// Only when new
	if (empty($scriptProperties[\'mode\']) || $scriptProperties[\'mode\'] !== \'new\') return;
	
	// Siblings
	$c = $modx->newQuery(\'modResource\', array(\'parent\'=>$_REQUEST[\'parent\']));
	$c->sortby(\'id\', \'desc\'); // Reference last added sibling
	$siblings = $modx->getCollection(\'modResource\', $c);
	if(count($siblings)>0){
		$bro = array_shift($siblings);
		$modx->controller->setProperty(\'template\', $bro->get(\'template\'));
		return;
	}
	// No siblings, use parent
	if((int)$_REQUEST[\'parent\']!=0){
		$dad = $modx->getObject(\'modResource\', $_REQUEST[\'parent\']);
		$modx->controller->setProperty(\'template\', $dad->get(\'template\'));
		return;
	}
}

return;',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    4 => 
    array (
      'id' => '4',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'ClientConfig',
      'description' => 'Sets system settings from the Client Config CMP.',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => '/**
 * ClientConfig
 *
 * Copyright 2011-2014 by Mark Hamstra <hello@markhamstra.com>
 *
 * ClientConfig is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * ClientConfig is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ClientConfig; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * @package clientconfig
 *
 * @var modX $modx
 * @var int $id
 * @var string $mode
 * @var modResource $resource
 * @var modTemplate $template
 * @var modTemplateVar $tv
 * @var modChunk $chunk
 * @var modSnippet $snippet
 * @var modPlugin $plugin
*/

$eventName = $modx->event->name;

switch($eventName) {
    case \'OnMODXInit\':
        /* Grab the class */
        $path = $modx->getOption(\'clientconfig.core_path\', null, $modx->getOption(\'core_path\') . \'components/clientconfig/\');
        $path .= \'model/clientconfig/\';
        $clientConfig = $modx->getService(\'clientconfig\',\'ClientConfig\', $path);

        /* If we got the class (gotta be careful of failed migrations), grab settings and go! */
        if ($clientConfig instanceof ClientConfig) {
            $settings = $clientConfig->getSettings();

            /* Make settings available as [[++tags]] */
            $modx->setPlaceholders($settings, \'+\');

            /* Make settings available for $modx->getOption() */
            foreach ($settings as $key => $value) {
                $modx->setOption($key, $value);
            }
        }
        break;
}

return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    5 => 
    array (
      'id' => '5',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'Collections',
      'description' => '',
      'editor_type' => '0',
      'category' => '3',
      'cache_type' => '0',
      'plugincode' => '/**
 * Collections
 *
 * DESCRIPTION
 *
 * This plugin inject JS to handle proper working of close buttons in Resource\'s panel (OnDocFormPrerender)
 * This plugin handles setting proper show_in_tree parameter (OnBeforeDocFormSave, OnResourceSort)
 *
 * @var modX $modx
 * @var array $scriptProperties
 */
$corePath = $modx->getOption(\'collections.core_path\', null, $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components/collections/\');
/** @var Collections $collections */
$collections = $modx->getService(
    \'collections\',
    \'Collections\',
    $corePath . \'model/collections/\',
    array(
        \'core_path\' => $corePath
    )
);

$className = \'Collections\' . $modx->event->name;

$modx->loadClass(\'CollectionsPlugin\', $collections->getOption(\'modelPath\') . \'collections/events/\', true, true);
$modx->loadClass($className, $collections->getOption(\'modelPath\') . \'collections/events/\', true, true);

if (class_exists($className)) {
    /** @var CollectionsPlugin $handler */
    $handler = new $className($modx, $scriptProperties);
    $handler->run();
}

return;',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    6 => 
    array (
      'id' => '6',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'FormIt',
      'description' => '',
      'editor_type' => '0',
      'category' => '4',
      'cache_type' => '0',
      'plugincode' => '/**
 * FormIt
 *
 * Copyright 2009-2017 by Sterc <modx@sterc.nl>
 *
 * FormIt is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option) any
 * later version.
 *
 * FormIt is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * FormIt; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 *
 * @package formit
 */
/**
 * FormIt plugin
 *
 * @package formit
 */

$formit = $modx->getService(
    \'formit\',
    \'FormIt\',
    $modx->getOption(\'formit.core_path\', null, $modx->getOption(\'core_path\').\'components/formit/\') .\'model/formit/\',
    array()
);

if (!($formit instanceof FormIt)) {
    return;
}

switch ($modx->event->name) {
    case \'OnManagerPageBeforeRender\':
        // If migration status is false, show migrate alert message bar in manager
        if (method_exists(\'FormIt\',\'encryptionMigrationStatus\')) {
            if (!$formit->encryptionMigrationStatus()) {
                $modx->lexicon->load(\'formit:mgr\');
                $properties = array(\'message\' => $modx->lexicon(\'formit.migrate_alert\'));
                $chunk = $formit->_getTplChunk(\'migrate/alert\');
                if ($chunk) {
                    $modx->regClientStartupHTMLBlock($chunk->process($properties));
                    $modx->regClientCSS($formit->config[\'cssUrl\'] . \'migrate.css\');
                }
            }
        }
}',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    7 => 
    array (
      'id' => '7',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'MIGX',
      'description' => '',
      'editor_type' => '0',
      'category' => '5',
      'cache_type' => '0',
      'plugincode' => '$corePath = $modx->getOption(\'migx.core_path\',null,$modx->getOption(\'core_path\').\'components/migx/\');
$assetsUrl = $modx->getOption(\'migx.assets_url\', null, $modx->getOption(\'assets_url\') . \'components/migx/\');
switch ($modx->event->name) {
    case \'OnTVInputRenderList\':
        $modx->event->output($corePath.\'elements/tv/input/\');
        break;
    case \'OnTVInputPropertiesList\':
        $modx->event->output($corePath.\'elements/tv/inputoptions/\');
        break;

        case \'OnDocFormPrerender\':
        $modx->controller->addCss($assetsUrl.\'css/mgr.css\');
        break; 
 
    /*          
    case \'OnTVOutputRenderList\':
        $modx->event->output($corePath.\'elements/tv/output/\');
        break;
    case \'OnTVOutputRenderPropertiesList\':
        $modx->event->output($corePath.\'elements/tv/properties/\');
        break;
    
    case \'OnDocFormPrerender\':
        $assetsUrl = $modx->getOption(\'colorpicker.assets_url\',null,$modx->getOption(\'assets_url\').\'components/colorpicker/\'); 
        $modx->regClientStartupHTMLBlock(\'<script type="text/javascript">
        Ext.onReady(function() {
            
        });
        </script>\');
        $modx->regClientStartupScript($assetsUrl.\'sources/ColorPicker.js\');
        $modx->regClientStartupScript($assetsUrl.\'sources/ColorMenu.js\');
        $modx->regClientStartupScript($assetsUrl.\'sources/ColorPickerField.js\');		
        $modx->regClientCSS($assetsUrl.\'resources/css/colorpicker.css\');
        break;
     */
}
return;',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    9 => 
    array (
      'id' => '9',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'migxResizeOnUpload',
      'description' => '',
      'editor_type' => '0',
      'category' => '5',
      'cache_type' => '0',
      'plugincode' => '/**
 * migxResizeOnUpload Plugin
 *
 * Events: OnFileManagerUpload
 * Author: Bruno Perner <b.perner@gmx.de>
 * Modified to read multiple configs from mediasource-property
 * 
 * First Author: Vasiliy Naumkin <bezumkin@yandex.ru>
 * Required: PhpThumbOf snippet for resizing images
 * 
 * Example: mediasource - property \'resizeConfig\':
 * [{"alias":"origin","w":"500","h":"500","far":1},{"alias":"thumb","w":"150","h":"150","far":1}]
 */

if ($modx->event->name != \'OnFileManagerUpload\') {
    return;
}


$file = $modx->event->params[\'files\'][\'file\'];
$directory = $modx->event->params[\'directory\'];

if ($file[\'error\'] != 0) {
    return;
}

$name = $file[\'name\'];
//$extensions = explode(\',\', $modx->getOption(\'upload_images\'));

$source = $modx->event->params[\'source\'];

if ($source instanceof modMediaSource) {
    //$dirTree = $modx->getOption(\'dirtree\', $_REQUEST, \'\');
    //$modx->setPlaceholder(\'docid\', $resource_id);
    $source->initialize();
    $basePath = str_replace(\'/./\', \'/\', $source->getBasePath());
    //$cachepath = $cachepath . $dirTree;
    $baseUrl = $modx->getOption(\'site_url\') . $source->getBaseUrl();
    //$baseUrl = $baseUrl . $dirTree;
    $sourceProperties = $source->getPropertyList();

    //echo \'<pre>\' . print_r($sourceProperties, 1) . \'</pre>\';
    //$allowedExtensions = $modx->getOption(\'allowedFileTypes\', $sourceProperties, \'\');
    //$allowedExtensions = empty($allowedExtensions) ? \'jpg,jpeg,png,gif\' : $allowedExtensions;
    //$maxFilesizeMb = $modx->getOption(\'maxFilesizeMb\', $sourceProperties, \'8\');
    //$maxFiles = $modx->getOption(\'maxFiles\', $sourceProperties, \'0\');
    //$thumbX = $modx->getOption(\'thumbX\', $sourceProperties, \'100\');
    //$thumbY = $modx->getOption(\'thumbY\', $sourceProperties, \'100\');
    $resizeConfigs = $modx->getOption(\'resizeConfigs\', $sourceProperties, \'\');
    $resizeConfigs = $modx->fromJson($resizeConfigs);
    $thumbscontainer = $modx->getOption(\'thumbscontainer\', $sourceProperties, \'thumbs/\');
    $imageExtensions = $modx->getOption(\'imageExtensions\', $sourceProperties, \'jpg,jpeg,png,gif,JPG\');
    $imageExtensions = explode(\',\', $imageExtensions);
    //$uniqueFilenames = $modx->getOption(\'uniqueFilenames\', $sourceProperties, false);
    //$onImageUpload = $modx->getOption(\'onImageUpload\', $sourceProperties, \'\');
    //$onImageRemove = $modx->getOption(\'onImageRemove\', $sourceProperties, \'\');
    $cleanalias = $modx->getOption(\'cleanFilename\', $sourceProperties, false);

}

if (is_array($resizeConfigs) && count($resizeConfigs) > 0) {
    foreach ($resizeConfigs as $rc) {
        if (isset($rc[\'alias\'])) {
            $filePath = $basePath . $directory;
            $filePath = str_replace(\'//\',\'/\',$filePath);
            if ($rc[\'alias\'] == \'origin\') {
                $thumbPath = $filePath;
            } else {
                $thumbPath = $filePath . $rc[\'alias\'] . \'/\';
                $permissions = octdec(\'0\' . (int)($modx->getOption(\'new_folder_permissions\', null, \'755\', true)));
                if (!@mkdir($thumbPath, $permissions, true)) {
                    $modx->log(MODX_LOG_LEVEL_ERROR, sprintf(\'[migxResourceMediaPath]: could not create directory %s).\', $thumbPath));
                } else {
                    chmod($thumbPath, $permissions);
                }

            }


            $filename = $filePath . $name;
            $thumbname = $thumbPath . $name;
            $ext = substr(strrchr($name, \'.\'), 1);
            if (in_array($ext, $imageExtensions)) {
                $sizes = getimagesize($filename);
                echo $sizes[0]; 
                //$format = substr($sizes[\'mime\'], 6);
                if ($sizes[0] > $rc[\'w\'] || $sizes[1] > $rc[\'h\']) {
                    if ($sizes[0] < $rc[\'w\']) {
                        $rc[\'w\'] = $sizes[0];
                    }
                    if ($sizes[1] < $rc[\'h\']) {
                        $rc[\'h\'] = $sizes[1];
                    }
                    $type = $sizes[0] > $sizes[1] ? \'landscape\' : \'portrait\';
                    if (isset($rc[\'far\']) && $rc[\'far\'] == \'1\' && isset($rc[\'w\']) && isset($rc[\'h\'])) {
                        if ($type = \'landscape\') {
                            unset($rc[\'h\']);
                        }else {
                            unset($rc[\'w\']);
                        }
                    }

                    $options = \'\';
                    foreach ($rc as $k => $v) {
                        if ($k != \'alias\') {
                            $options .= \'&\' . $k . \'=\' . $v;
                        }
                    }
                    $resized = $modx->runSnippet(\'phpthumbof\', array(\'input\' => $filePath . $name, \'options\' => $options));
                    rename(MODX_BASE_PATH . substr($resized, 1), $thumbname);
                }
            }


        }
    }
}',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    10 => 
    array (
      'id' => '10',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'MinifyX',
      'description' => '',
      'editor_type' => '0',
      'category' => '6',
      'cache_type' => '0',
      'plugincode' => 'switch ($modx->event->name) {

	case \'OnSiteRefresh\':
		if ($MinifyX = $modx->getService(\'minifyx\',\'MinifyX\', MODX_CORE_PATH.\'components/minifyx/model/minifyx/\')) {
			/** @var MinifyX $MinifyX */
			$MinifyX = new MinifyX($modx, array());
			if ($MinifyX->clearCache()) {
				$modx->log(modX::LOG_LEVEL_INFO, $modx->lexicon(\'refresh_default\').\': MinifyX\');
			}
		}
		break;

	case \'OnWebPagePrerender\':
		$time = microtime(true);
		// Process scripts and styles
		if ($modx->getOption(\'minifyx_process_registered\', null, false, true)) {
			if (!$modx->getService(\'minifyx\',\'MinifyX\', MODX_CORE_PATH.\'components/minifyx/model/minifyx/\')) {return false;}

			$current = array(
				\'head\' => $modx->sjscripts,
				\'body\' => $modx->jscripts,
			);
			$included = $excluded = $prepared = $raw = array(
				\'head\' => array(\'css\' => array(), \'js\' => array(), \'html\' => array()),
				\'body\' => array(\'css\' => array(), \'js\' => array(), \'html\' => array()),
			);
			$exclude = $modx->getOption(\'minifyx_exclude_registered\');

			// Split all scripts and styles by type
			foreach ($current as $key => $value) {
				foreach ($value as $v) {
					if (preg_match(\'/<(?:link|script).*?(?:href|src)=[\\\'|"](.*?)[\\\'|"]/\', $v, $tmp)) {
						if (strpos($tmp[1], \'.css\') !== false) {
							if (!empty($exclude) && preg_match($exclude, $tmp[1])) {
								$excluded[$key][\'css\'][] = $tmp[1];
							}
							else {
								$included[$key][\'css\'][] = $tmp[1];
							}
						}
						if (strpos($tmp[1], \'.js\') !== false) {
							if (!empty($exclude) && preg_match($exclude, $tmp[1])) {
								$excluded[$key][\'js\'][] = $tmp[1];
							}
							else {
								$included[$key][\'js\'][] = $tmp[1];
							}
						}
					}
					elseif (strpos($v, \'<script\') !== false) {
						$raw[$key][\'js\'][] = trim(preg_replace(\'#<!--.*?-->(\\n|)#s\', \'\', $v));
					}
					elseif (strpos($v, \'<style\') !== false) {
						$raw[$key][\'css\'][] = trim(preg_replace(\'#/\\*.*?\\*/(\\n|)#s\', \'\', $v));
					}
					else {
						$excluded[$key][\'html\'][] = $v;
					}
				}
			}

			// Main options for MinifyX
			$scriptProperties = array(
				\'cacheFolder\' => $modx->getOption(\'minifyx_cacheFolder\', null, \'/assets/components/minifyx/cache/\', true),
				\'forceUpdate\' => $modx->getOption(\'minifyx_forceUpdate\', null, false, true),
				\'minifyJs\' => $modx->getOption(\'minifyx_minifyJs\', null, false, true),
				\'minifyCss\' => $modx->getOption(\'minifyx_minifyCss\', null, false, true),
				\'jsFilename\' => $modx->getOption(\'minifyx_jsFilename\', null, \'all\', true),
				\'cssFilename\' => $modx->getOption(\'minifyx_cssFilename\', null, \'all\', true),
			);

			/** @var MinifyX $MinifyX */
			$MinifyX = new MinifyX($modx, $scriptProperties);
			if (!$MinifyX->prepareCacheFolder()) {
				$this->modx->log(modX::LOG_LEVEL_ERROR, \'[MinifyX] Could not create cache dir "\'.$scriptProperties[\'cacheFolder\'].\'"\');
				return;
			}
			$cacheFolderUrl = MODX_BASE_URL . str_replace(MODX_BASE_PATH, \'\', $MinifyX->config[\'cacheFolder\']);

			// Process raw scripts and styles
			$tmp_dir = $MinifyX->getTmpDir() . \'resources/\' . $modx->resource->id . \'/\';
			foreach ($raw as $key => $value) {
				foreach ($value as $type => $rows) {
					$tmp = \'\';
					if ($type == \'css\' && $modx->getOption(\'minifyx_processRawCss\', null, false, true) ||
						$type == \'js\' && $modx->getOption(\'minifyx_processRawJs\', null, false, true)) {

						$text = \'\';
						foreach ($rows as $text) {
							$text = preg_replace(\'#^<(script|style).*?>#\', \'\', $text);
							$text = preg_replace(\'#</(script|style)>$#\', \'\', $text);
							$tmp .= $text;
						}

						if (!empty($tmp)) {
							$file = sha1($tmp) . \'.\' . $type;
							if (!file_exists($tmp_dir . $file)) {
								if (!file_exists($tmp_dir)) {
									$MinifyX->makeDir($tmp_dir);
								}
								file_put_contents($tmp_dir . $file, $tmp);
							}
							$included[$key][$type][] = $tmp_dir . $file;
							$raw[$key][$type] = array();
						}
					}
				}
			}

			// Combine and minify files
			foreach ($included as $key => $value) {
				foreach ($value as $type => $files) {
					if (empty($files)) {continue;}

					$filename = $MinifyX->config[$type.\'Filename\'] . \'_\';
					$extension = $MinifyX->config[$type.\'Ext\'];

					$files = $MinifyX->prepareFiles(implode(\',\', $files));
					$properties = array(
						\'minify\' => $MinifyX->config[\'minify\'.ucfirst($type)]
								? \'true\'
								: \'false\',
					);

					$result = $MinifyX->Munee($files, $properties);
					$file = $MinifyX->saveFile($result, $filename, $extension);
					if (!empty($file)) {
						$prepared[$key][$type][] = $cacheFolderUrl . $file;
					}
				}
			}

			// Combine files by type
			$final = array(
				\'head\' => array_merge(
					$excluded[\'head\'][\'css\'], $prepared[\'head\'][\'css\'], $raw[\'head\'][\'css\'],
					$excluded[\'head\'][\'js\'], $prepared[\'head\'][\'js\'], $raw[\'head\'][\'js\']
				),
				\'body\' => array_merge(
					$excluded[\'body\'][\'css\'], $prepared[\'body\'][\'css\'], $raw[\'body\'][\'css\'],
					$excluded[\'body\'][\'js\'], $prepared[\'body\'][\'js\'], $raw[\'body\'][\'js\']
				),
			);

			// Push files to tags
			foreach ($final as $type => &$value) {
				foreach ($value as &$file) {
					if (strpos($file, \'<script\') === false && strpos($file, \'<style\') === false) {
						$file = preg_match(\'/\\.css$/iu\', $file)
							? \'<link rel="stylesheet" href="\' . $file . \'" type="text/css" />\'
							: \'<script type="text/javascript" src="\' . $file . \'"></script>\';
					}
				}
				if (!empty($excluded[$type][\'html\'])) {
					$value[] = implode("\\n", $excluded[$type][\'html\']);
				}
			}
			unset($value);

			// Replace tags in web page
			$modx->resource->_output = str_replace(
				array($modx->getRegisteredClientStartupScripts() . "\\n</head>", $modx->getRegisteredClientScripts() . "\\n</body>"),
				array(implode("\\n", $final[\'head\']) . "\\n</head>", implode("\\n", $final[\'body\']) . "\\n</body>"),
				$modx->resource->_output
			);
		}

		// Process images
		if ($modx->getOption(\'minifyx_process_images\', null, false, true)) {
			if (!$modx->getService(\'minifyx\',\'MinifyX\', MODX_CORE_PATH.\'components/minifyx/model/minifyx/\')) {return false;}

			$connector = $modx->getOption(\'minifyx_connector\', null, \'/assets/components/minifyx/munee.php\', true);
			$exclude = $modx->getOption(\'minifyx_exclude_images\');
			$replace = array(\'from\' => array(), \'to\' => array());
			$site_url = $modx->getOption(\'site_url\');
			$default = $modx->getOption(\'minifyx_images_filters\', null, \'\', true);

			preg_match_all(\'/<img.*?>/i\', $modx->resource->_output, $tags);
			foreach ($tags[0] as $tag) {
				if (preg_match($exclude, $tag)) {
					continue;
				}
				elseif (preg_match_all(\'/(src|height|width|filters)=[\\\'|"](.*?)[\\\'|"]/i\', $tag, $properties)) {
					if (count($properties[0]) >= 2) {
						$file = $connector . \'?files=\';
						$resize = \'\';
						$filters = \'\';
						$tmp = array(\'from\' => array(), \'to\' => array());

						foreach ($properties[1] as $k => $v) {
							if ($v == \'src\') {
								$src = $properties[2][$k];
								if (strpos($src, \'://\') !== false) {
									if (strpos($src, $site_url) !== false) {
										$src = str_replace($site_url, \'\', $src);
									}
									else {
										// Image from 3rd party domain
										continue;
									}
								}
								$file .= $src;
								$tmp[\'from\'][\'src\'] = $properties[2][$k];
							}
							elseif ($v == \'height\' || $v == \'width\') {
								$resize .=  $v[0] . \'[\'.$properties[2][$k].\']\';
							}
							elseif ($v == \'filters\') {
								$filters .= $properties[2][$k];
								$tmp[\'from\'][\'filters\'] = $properties[0][$k];
								$tmp[\'to\'][\'filters\'] = \'\';
							}
						}

						if (!empty($tmp[\'from\'][\'src\'])) {
							$resize .= isset($tmp[\'from\'][\'filters\'])
								? $filters
								: $default;
							$tmp[\'to\'][\'src\'] = $file . \'?resize=\' . $resize;

							ksort($tmp[\'from\']);
							ksort($tmp[\'to\']);

							$replace[\'from\'][] = $tag;
							$replace[\'to\'][] = str_replace($tmp[\'from\'], $tmp[\'to\'], $tag);
						}
					}
				}
			}

			if (!empty($replace)) {
				$modx->resource->_output = str_replace(
					$replace[\'from\'],
					$replace[\'to\'],
					$modx->resource->_output
				);
			}
		}

		$modx->log(modX::LOG_LEVEL_INFO, \'[MinifyX] Total time for page "\'.$modx->resource->id.\'" = \'.(microtime(true) - $time));
		break;
}',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/minifyx/elements/plugins/plugin.minifyx.php',
    ),
    11 => 
    array (
      'id' => '11',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'pdoTools',
      'description' => '',
      'editor_type' => '0',
      'category' => '7',
      'cache_type' => '0',
      'plugincode' => '/** @var modX $modx */
switch ($modx->event->name) {

    case \'OnMODXInit\':
        $fqn = $modx->getOption(\'pdoTools.class\', null, \'pdotools.pdotools\', true);
        $path = $modx->getOption(\'pdotools_class_path\', null, MODX_CORE_PATH . \'components/pdotools/model/\', true);
        $modx->loadClass($fqn, $path, false, true);

        $fqn = $modx->getOption(\'pdoFetch.class\', null, \'pdotools.pdofetch\', true);
        $path = $modx->getOption(\'pdofetch_class_path\', null, MODX_CORE_PATH . \'components/pdotools/model/\', true);
        $modx->loadClass($fqn, $path, false, true);
        break;

    case \'OnSiteRefresh\':
        /** @var pdoTools $pdoTools */
        if ($pdoTools = $modx->getService(\'pdoTools\')) {
            if ($pdoTools->clearFileCache()) {
                $modx->log(modX::LOG_LEVEL_INFO, $modx->lexicon(\'refresh_default\') . \': pdoTools\');
            }
        }
        break;

    case \'OnWebPagePrerender\':
        $parser = $modx->getParser();
        if ($parser instanceof pdoParser) {
            foreach ($parser->pdoTools->ignores as $key => $val) {
                $modx->resource->_output = str_replace($key, $val, $modx->resource->_output);
            }
        }
        break;
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/pdotools/elements/plugins/plugin.pdotools.php',
    ),
    12 => 
    array (
      'id' => '12',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'phpThumbOfCacheManager',
      'description' => 'Handles cache cleaning when clearing the Site Cache.',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => '/**
 * phpThumbOf
 *
 * Copyright 2009-2012 by Shaun McCormick <shaun@modx.com>
 *
 * phpThumbOf is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option) any
 * later version.
 *
 * phpThumbOf is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * phpThumbOf; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * @package phpthumbof
 */
/**
 * Handles cache management for phpthumbof filter
 *
 * @var \\modX $modx
 * @var array $scriptProperties
 *
 * @package phpthumbof
 */
if (empty($results)) $results = array();

switch ($modx->event->name) {
    case \'OnSiteRefresh\':
        if (!$modx->loadClass(\'modPhpThumb\',$modx->getOption(\'core_path\').\'model/phpthumb/\',true,true)) {
            $modx->log(modX::LOG_LEVEL_ERROR,\'[phpThumbOf] Could not load modPhpThumb class in plugin.\');
            return;
        }
        $assetsPath = $modx->getOption(\'phpthumbof.assets_path\',$scriptProperties,$modx->getOption(\'assets_path\').\'components/phpthumbof/\');
        $phpThumb = new modPhpThumb($modx);
        $cacheDir = $assetsPath.\'cache/\';

        /* clear local cache */
        if (!empty($cacheDir)) {
            /** @var DirectoryIterator $file */
            foreach (new DirectoryIterator($cacheDir) as $file) {
                if (!$file->isFile()) continue;
                @unlink($file->getPathname());
            }
        }

        /* if using amazon s3, clear our cache there */
        $useS3 = $modx->getOption(\'phpthumbof.use_s3\',$scriptProperties,false);
        if ($useS3) {
            $modelPath = $modx->getOption(\'phpthumbof.core_path\',null,$modx->getOption(\'core_path\').\'components/phpthumbof/\').\'model/\';
            /** @var modAws $modaws */
            $modaws = $modx->getService(\'modaws\',\'modAws\',$modelPath.\'aws/\',$scriptProperties);
            $s3path = $modx->getOption(\'phpthumbof.s3_path\',null,\'phpthumbof/\');
            
            $list = $modaws->getObjectList($s3path);
            if (!empty($list) && is_array($list)) {
                foreach ($list as $obj) {
                    if (empty($obj->Key)) continue;

                    $results[] = $modaws->deleteObject($obj->Key);
                }
            }
        }

        break;
}
return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    14 => 
    array (
      'id' => '14',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'miniShop2',
      'description' => '',
      'editor_type' => '0',
      'category' => '9',
      'cache_type' => '0',
      'plugincode' => '/** @var modX $modx */
switch ($modx->event->name) {

    case \'OnMODXInit\':
        // Load extensions
        /** @var miniShop2 $miniShop2 */
        if ($miniShop2 = $modx->getService(\'miniShop2\')) {
            $miniShop2->loadMap();
        }
        break;

    case \'OnHandleRequest\':
        // Handle ajax requests
        $isAjax = !empty($_SERVER[\'HTTP_X_REQUESTED_WITH\']) && $_SERVER[\'HTTP_X_REQUESTED_WITH\'] == \'XMLHttpRequest\';
        if (empty($_REQUEST[\'ms2_action\']) || !$isAjax) {
            return;
        }
        /** @var miniShop2 $miniShop2 */
        if ($miniShop2 = $modx->getService(\'miniShop2\')) {
            $response = $miniShop2->handleRequest($_REQUEST[\'ms2_action\'], @$_POST);
            @session_write_close();
            exit($response);
        }
        break;

    case \'OnLoadWebDocument\':
        // Handle non-ajax requests
        if (!empty($_REQUEST[\'ms2_action\'])) {
            if ($miniShop2 = $modx->getService(\'miniShop2\')) {
                $miniShop2->handleRequest($_REQUEST[\'ms2_action\'], @$_POST);
            }
        }
        // Set product fields as [[*resource]] tags
        if ($modx->resource->get(\'class_key\') == \'msProduct\') {
            if ($dataMeta = $modx->getFieldMeta(\'msProductData\')) {
                unset($dataMeta[\'id\']);
                $modx->resource->_fieldMeta = array_merge(
                    $modx->resource->_fieldMeta,
                    $dataMeta
                );
            }
        }
        break;

    case \'OnWebPageInit\':
        // Set referrer cookie
        /** @var msCustomerProfile $profile */
        $referrerVar = $modx->getOption(\'ms2_referrer_code_var\', null, \'msfrom\', true);
        $cookieVar = $modx->getOption(\'ms2_referrer_cookie_var\', null, \'msreferrer\', true);
        $cookieTime = $modx->getOption(\'ms2_referrer_time\', null, 86400 * 365, true);

        if (!$modx->user->isAuthenticated() && !empty($_REQUEST[$referrerVar])) {
            $code = trim($_REQUEST[$referrerVar]);
            if ($profile = $modx->getObject(\'msCustomerProfile\', array(\'referrer_code\' => $code))) {
                $referrer = $profile->get(\'id\');
                setcookie($cookieVar, $referrer, time() + $cookieTime);
            }
        }
        break;

    case \'OnUserSave\':
        // Save referrer id
        if ($mode == modSystemEvent::MODE_NEW) {
            /** @var modUser $user */
            $cookieVar = $modx->getOption(\'ms2_referrer_cookie_var\', null, \'msreferrer\', true);
            $cookieTime = $modx->getOption(\'ms2_referrer_time\', null, 86400 * 365, true);
            if ($modx->context->key != \'mgr\' && !empty($_COOKIE[$cookieVar])) {
                if ($profile = $modx->getObject(\'msCustomerProfile\', array(\'id\' => $user->get(\'id\')))) {
                    if (!$profile->get(\'referrer_id\') && $_COOKIE[$cookieVar] != $user->get(\'id\')) {
                        $profile->set(\'referrer_id\', (int)$_COOKIE[$cookieVar]);
                        $profile->save();
                    }
                }
                setcookie($cookieVar, \'\', time() - $cookieTime);
            }
        }
        break;

    case \'msOnChangeOrderStatus\':
        // Update customer stat
        if (empty($status) || $status != 2) {
            return;
        }

        /** @var modUser $user */
        if ($user = $order->getOne(\'User\')) {
            $q = $modx->newQuery(\'msOrder\', array(\'type\' => 0));
            $q->innerJoin(\'modUser\', \'modUser\', array(\'modUser.id = msOrder.user_id\'));
            $q->innerJoin(\'msOrderLog\', \'msOrderLog\', array(
                \'msOrderLog.order_id = msOrder.id\',
                \'msOrderLog.action\' => \'status\',
                \'msOrderLog.entry\' => $status,
            ));
            $q->where(array(\'msOrder.user_id\' => $user->get(\'id\')));
            $q->groupby(\'msOrder.user_id\');
            $q->select(\'SUM(msOrder.cost)\');
            if ($q->prepare() && $q->stmt->execute()) {
                $spent = $q->stmt->fetchColumn();
                /** @var msCustomerProfile $profile */
                if ($profile = $modx->getObject(\'msCustomerProfile\', array(\'id\' => $user->get(\'id\')))) {
                    $profile->set(\'spent\', $spent);
                    $profile->save();
                }
            }
        }
        break;
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/minishop2/elements/plugins/plugin.minishop2.php',
    ),
    15 => 
    array (
      'id' => '15',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'msDiscount',
      'description' => '',
      'editor_type' => '0',
      'category' => '10',
      'cache_type' => '0',
      'plugincode' => '/** @var msDiscount $msDiscount */
$msDiscount = $modx->getService(\'msDiscount\');

switch ($modx->event->name) {

	case \'msOnGetProductPrice\':
		if ($modx->context->key == \'mgr\') {return;}
		/**
		 * Counts discount of current product for current user, based on rules in msDiscount component
		 * New price must be set in $modx->event->returnedValues[\'price\']
		 *
		 * @var msProductData $product Object with product properties
		 * @var array $data Array with product properties. Can be empty!
		 * @var float $price Current price of product
		 */
		if (!isset($modx->event->returnedValues[\'price\'])) {
			$modx->event->returnedValues[\'price\'] = $price;
		}
		// Get link to product price
		$price = & $modx->event->returnedValues[\'price\'];
		$new_price = $msDiscount->getNewPrice($product->id, $price);
		if ($new_price !== false) {
			$price = $new_price;
		}
		break;

	case \'msOnChangeOrderStatus\':
		/**
		 * Add user to discounts group if he spent required sum for join
		 *
		 * @var msOrder $order
		 * @var integer $status
		 */
		if ($status != 2) {return;}

		/** @var modUser $user */
		if ($user = $order->getOne(\'User\')) {
			if ($profile = $modx->getObject(\'msCustomerProfile\', $user->id)) {
				$spent = $profile->spent;
				if ($spent > 0) {
					$q = $modx->newQuery(\'msdUserGroup\');
					$q->where(\'joinsum > 0\');
					$q->select(\'id,joinsum\');
					if ($q->prepare() && $q->stmt->execute()) {
						$groups = $msDiscount->getUserGroups($user->id);
						while ($row = $q->stmt->fetch(PDO::FETCH_ASSOC)) {
							if ($spent > $row[\'joinsum\'] && !isset($groups[$row[\'id\']])) {
								$user->joinGroup((integer) $row[\'id\'], 1);
							}
						}
					}
				}
			}
		}
		break;

	case \'msOnBeforeAddToOrder\':
		/** @var string $key */
		if ($key == \'coupon_code\' && !empty($value)) {
			$check = $msDiscount->checkCoupon($value);
			if ($check !== true) {
				$modx->event->output($check);
			}
		}
		break;

	case \'msOnGetOrderCost\':
		/** @var float $cost */
		if (!empty($with_cart) && !empty($cost)) {
			/**@var msOrderInterface $order */
			if ($data = $order->get()) {
				if (!empty($data[\'coupon_code\']) && $msDiscount->checkCoupon($data[\'coupon_code\']) === true) {
					$order_cost = $cost;
					if ($modx->getOption(\'msd_coupon_only_products\', null, true)) {
						/** @var msCartHandler $cart */
						$tmp = $cart->status();
						$order_cost = $tmp[\'total_cost\'];
					}
					if ($discount = $msDiscount->getCouponDiscount($data[\'coupon_code\'], $order_cost)) {
						$cost -= $discount;
					}
					if ($cost >= 0) {
						$modx->event->returnedValues[\'cost\'] = $cost;
					}
				}
			}
		}
		break;

	case \'msOnCreateOrder\':
		/**@var msOrderInterface $order */
		if ($data = $order->get()) {
			/**@var msdCoupon $coupon */
			if (!empty($data[\'coupon_code\']) && $coupon = $modx->getObject(\'msdCoupon\', array(\'code\' => $data[\'coupon_code\']))) {
				/**@var msOrder $msOrder */
				$coupon->fromArray(array(
					\'active\' => false,
					\'activatedon\' => date(\'Y-m-d H:i:s\'),
					\'order_id\' => $msOrder->get(\'id\'),
				));
				$coupon->save();
				$properties = $msOrder->get(\'properties\');
				if (!is_array($properties)) {
					$properties = array();
				}
				$properties[\'coupon_code\'] = $coupon->get(\'code\');
				if ($group = $coupon->getOne(\'Group\')) {
					$properties[\'coupon_discount\'] = $group->get(\'discount\');
				}
				$msOrder->set(\'properties\', $properties);
				$msOrder->save();
			}
		}
		break;

	case \'OnWebLogin\':
	case \'OnWebLogout\':
		/** Set flag for cart reload */
		$_SESSION[\'minishop2\'][\'cart_reload\'] = true;
		break;

	case \'OnLoadWebDocument\':
		/**
		 * Recalculate cart of user if flag is set
		 * @var miniShop2 $miniShop2
		 */
		if (empty($_SESSION[\'minishop2\'][\'cart_reload\'])) {return;}

		$miniShop2 = $modx->getService(\'miniShop2\');
		$miniShop2->initialize($modx->context->key);

		$cart = $miniShop2->cart->get();
		if (!empty($cart)) {
			foreach ($cart as $key => $item) {
				/** @var msProduct $product */
				if ($product = $modx->getObject(\'msProductData\', $item[\'id\'])) {
					$cart[$key][\'price\'] = $product->getPrice();
				}
			}
			$miniShop2->cart->set($cart);
		}
		unset($_SESSION[\'minishop2\'][\'cart_reload\']);
		break;
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/msdiscount/elements/plugins/plugin.msdiscount.php',
    ),
    16 => 
    array (
      'id' => '16',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'mSearch2',
      'description' => '',
      'editor_type' => '0',
      'category' => '11',
      'cache_type' => '0',
      'plugincode' => '$id = 0;

switch ($modx->event->name) {

	case \'OnDocFormSave\':
	case \'OnResourceDelete\':
	case \'OnResourceUndelete\':
		/* @var modResource $modResource */
		if (!empty($resource) && $resource instanceof modResource) {
			$id = $resource->get(\'id\');
		}
	break;

	case \'OnCommentSave\':
	case \'OnCommentRemove\':
	case \'OnCommentDelete\':
		/* @var TicketComment $TicketComment */
		if (!empty($TicketComment) && $TicketComment instanceof TicketComment) {
			$id = $TicketComment->getOne(\'Thread\')->get(\'resource\');
		}
	break;

}


if (!empty($id)) {
	/* @var modProcessorResponse $response */
	$response = $modx->runProcessor(\'mgr/index/update\', array(\'id\' => $id), array(\'processors_path\' => MODX_CORE_PATH . \'components/msearch2/processors/\'));

	if ($response->isError()) {
		$modx->log(modX::LOG_LEVEL_ERROR, print_r($response->getAllErrors(), true));
	}
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/msearch2/elements/plugins/plugin.msearch2.php',
    ),
    17 => 
    array (
      'id' => '17',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'mspBePaid',
      'description' => 'mspBePaid',
      'editor_type' => '0',
      'category' => '12',
      'cache_type' => '0',
      'plugincode' => '/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Ivan Klimchuk <ivan@klimchuk.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

switch ($modx->event->name) {
    case \'OnManagerPageBeforeRender\':

        if ($_GET[\'a\'] != \'system/settings\') {
            return;
        }

        $ms2connector = $modx->getOption(\'minishop2.assets_url\', null, $modx->getOption(\'assets_url\') . \'components/minishop2/\') . \'connector.php\';

        $modx->controller->addLexiconTopic(\'minishop2:default\');
        $modx->controller->addJavascript(MODX_ASSETS_URL . \'components/mspbepaid/js/mgr/bepaid.js\');
        $modx->controller->addHtml(\'<script>BePaidPayment.ms2connector = "\' . $ms2connector . \'";</script>\');

        $files = [
            \'language.combo.js\',
            \'country.combo.js\',
            \'status.combo.js\',
            \'resource.combo.js\',
            // for now I have troubles with integrate superboxselect type into system settings grid
            // so special types not used
//            \'readonly.combo.js\',
//            \'hidden.combo.js\'
        ];

        foreach ($files as $file) {
            $modx->controller->addJavascript(MODX_ASSETS_URL . \'components/mspbepaid/js/mgr/\' . $file);
        }

        break;
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '1',
      'static_file' => 'core/components/mspbepaid/elements/plugins/mspBePaid.php',
    ),
    18 => 
    array (
      'id' => '18',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'Office',
      'description' => '',
      'editor_type' => '0',
      'category' => '13',
      'cache_type' => '0',
      'plugincode' => '/** @var modX $modx */
switch ($modx->event->name) {
    case \'OnHandleRequest\':
        if (!empty($_GET[\'action\']) && $_GET[\'action\'] == \'office/login_as\') {
            $authorized = $modx->user->getSessionContexts();
            if (!empty($authorized[\'mgr\']) && $modx->context->key != \'mgr\') {
                /** @var modUser $user */
                if ((int)$_GET[\'user_id\'] && $user = $modx->getObject(\'modUser\', (int)$_GET[\'user_id\'])) {
                    if (empty($_SESSION[\'Office\'][\'LoggedIn\'])) {
                        $_SESSION[\'Office\'][\'LoggedIn\'] = array();
                    }
                    $_SESSION[\'Office\'][\'LoggedIn\'][$modx->user->id] = $modx->user->password;
                    $modx->user = $user;
                    $contexts = $modx->getIterator(\'modContext\', array(\'key:!=\' => \'mgr\'));
                    /** @var modContext $context */
                    foreach ($contexts as $context) {
                        $modx->user->addSessionContext($context->key);
                        $modx->getUser($context->key, true);
                    }
                    $_SESSION[\'Office\'][\'LoggedIn\'][$user->id] = $user->password;
                }
            }
            $url = preg_replace(\'#\\?.*#\', \'\', $_SERVER[\'REQUEST_URI\']);
            unset($_GET[\'action\'], $_GET[\'user_id\'], $_GET[$modx->getOption(\'request_param_alias\')]);
            if (!empty($_GET)) {
                $url .= \'?\' . http_build_query($_GET);
            }
            if (empty($url)) {
                $url = $modx->makeUrl($modx->getOption(\'site_start\'));
            }
            $modx->sendRedirect($url);
        }
        break;
    case \'OnManagerPageBeforeRender\':
        /** @var modManagerController $controller */
        switch ($controller->config[\'controller\']) {
            case \'security/user\':
                $controller->addLexiconTopic(\'office:default\');
                $controller->addLastJavascript(MODX_ASSETS_URL . \'components/office/js/main/mgr/users.js\');
                break;
            case \'security/user/update\':
                $controller->addLexiconTopic(\'office:default\');
                $controller->addLastJavascript(MODX_ASSETS_URL . \'components/office/js/main/mgr/user.js\');
                break;
        }
        break;
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/office/elements/plugins/plugin.office.php',
    ),
    19 => 
    array (
      'id' => '19',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'officeProfile',
      'description' => '',
      'editor_type' => '0',
      'category' => '13',
      'cache_type' => '0',
      'plugincode' => '/** @var modX $modx */
switch ($modx->event->name) {

    case \'OnLoadWebDocument\':
        if (!$modx->user->isAuthenticated($modx->context->key)) {
            return;
        }

        if (!$modx->user->active || $modx->user->Profile->blocked) {
            $modx->runProcessor(\'security/logout\');
            $modx->sendRedirect($modx->makeUrl($modx->getOption(\'site_start\'), \'\', \'\', \'full\'));
        } elseif ($page_id = $modx->getOption(\'office_profile_page_id\', null, false, true)) {
            if ($modx->resource->id != $page_id && $modx->resource->parent != $page_id && @rawurldecode($_REQUEST[\'action\']) != \'auth/logout\') {
                $required = array_map(\'trim\', explode(\',\', $modx->getOption(\'office_profile_required_fields\', null)));
                if (!in_array(\'email\', $required)) {
                    $required[] = \'email\';
                }
                $user = array_merge($modx->user->Profile->toArray(), $modx->user->toArray());
                $need = array();
                foreach ($required as $field) {
                    if (isset($user[$field]) && trim($user[$field]) == \'\') {
                        $need[] = $field;
                    } elseif (preg_match(\'/(.*?)\\[(.*?)\\]/\', $field, $matches)) {
                        if (empty($user[$matches[1]][$matches[2]])) {
                            $need[$matches[1] . \'.\' . $matches[2]] = $field;
                        }
                    }
                }
                if (!empty($need)) {
                    $modx->sendRedirect($modx->makeUrl($page_id, \'\', array(\'off_req\' => implode(\'-\', $need)), \'full\'));
                    @session_write_close();
                    die;
                }
            }
        }

        if ($modx->getOption(\'office_profile_force_email_as_username\', null, false)) {
            if (!empty($modx->user->Profile->email) && $modx->user->username != $modx->user->Profile->email) {
                $modx->user->set(\'username\', $modx->user->Profile->email);
                $modx->user->save();
            }
        }
        break;
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/office/elements/plugins/plugin.office.profile.php',
    ),
    20 => 
    array (
      'id' => '20',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'officeAuth',
      'description' => '',
      'editor_type' => '0',
      'category' => '13',
      'cache_type' => '0',
      'plugincode' => '/** @var modX $modx */
switch ($modx->event->name) {

    case \'OnHandleRequest\':
        $actions = array(\'auth/login\', \'auth/logout\', \'remote/login\', \'remote/logout\', \'auth/change\');

        if (!empty($_REQUEST[\'action\']) && in_array(rawurldecode($_REQUEST[\'action\']), $actions)) {
            $params = array();
            foreach ($_REQUEST as $k => $v) {
                $params[$k] = rawurldecode($v);
            }

            list($controller, $action) = explode(\'/\', $params[\'action\']);
            $cfg = !empty($_SESSION[\'Office\'][ucfirst($controller)][$modx->context->key])
                ? $_SESSION[\'Office\'][ucfirst($controller)][$modx->context->key]
                : array();

            /** @var Office $Office */
            $Office = $modx->getService(\'office\', \'Office\', MODX_CORE_PATH . \'components/office/model/office/\', $cfg);
            if ($Office) {
                $Office->loadAction($params[\'action\'], array_merge($cfg, $params));
            }
        } elseif ($modx->context->key != \'web\' && !$modx->user->id) {
            if ($user = $modx->getAuthenticatedUser($modx->context->key)) {
                $modx->user = $user;
                $modx->getUser($modx->context->key);
            }
        }

        if (!empty($_SESSION[\'Office\'][\'ReturnTo\'][$modx->context->key]) && $modx->user->isAuthenticated($modx->context->key)) {
            $return = $_SESSION[\'Office\'][\'ReturnTo\'][$modx->context->key];
            unset($_SESSION[\'Office\'][\'ReturnTo\'][$modx->context->key]);
            $modx->sendRedirect($return);
        }
        break;

    case \'OnWebAuthentication\':
        $modx->event->_output = !empty($_SESSION[\'Office\'][\'Auth\'][\'verified\']);
        break;

    case \'OnUserSave\':
        if (!empty($user) && !empty($mode) && $mode == \'new\') {
            if (!$user->get(\'remote_key\')) {
                $user->set(\'remote_key\', $user->get(\'id\'));
                $user->save();
            }
        }
        break;
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/office/elements/plugins/plugin.office.auth.php',
    ),
    22 => 
    array (
      'id' => '22',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'Sendex',
      'description' => '',
      'editor_type' => '0',
      'category' => '19',
      'cache_type' => '0',
      'plugincode' => 'switch ($modx->event->name) {

	case \'OnManagerPageInit\':
		$cssFile = MODX_ASSETS_URL.\'components/sendex/css/mgr/main.css\';
		$modx->regClientCSS($cssFile);
		break;

}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/sendex/elements/plugins/plugin.sendex.php',
    ),
    23 => 
    array (
      'id' => '23',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'HitsPage',
      'description' => 'HitsPage plugin for MODx Revolution',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => 'switch ($modx->event->name) {
    case \'OnWebPagePrerender\':
        if($modx->hpCount === true) {
            // get a reference to the output
			$output = &$modx->resource->_output;
    		if (preg_match_all ("/{%hp-(.*?)%}/",$output , $hp_list)) {
			  // If the array is not empty, choose the number of comments on the resource id (column rid)
			  if (is_array($hp_list)) {
				  array_walk($hp_list[1], \'intval\');
				  $hp = $modx->newQuery(\'modResource\', array(\'id:IN\' => $hp_list[1]));
				  $hp->select(array(\'modResource.id\',\'modResource.properties\'));
				  if ($hp->prepare() && $hp->stmt->execute()) {
					  $resultsHp = $hp->stmt->fetchAll(PDO::FETCH_ASSOC);
					  foreach ($resultsHp as $rHp) {
						  $objHP = json_decode($rHp[\'properties\']);
						  if (in_array($rHp[\'id\'],$hp_list[1])) {
							  $hp_list[1][array_search($rHp[\'id\'],$hp_list[1])] =  intval($objHP->hitspage->hitts);
						  }
					  }
				  }
			  }
			  // Replace all your templates in the resource to the correct values
			  $output = str_replace($hp_list[0], $hp_list[1], $output);
		  }
        }
    break;
}',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '1',
      'static_file' => 'core/components/hitspage/elements/plugins/hitspage.plugin.php',
    ),
    24 => 
    array (
      'id' => '24',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'seoPro',
      'description' => 'SEO optimizing plugin for MODx Revolution.',
      'editor_type' => '0',
      'category' => '26',
      'cache_type' => '0',
      'plugincode' => '/**
 * The base seoPro snippet.
 *
 * @package seopro
 */
$seoPro = $modx->getService(\'seopro\', \'seoPro\', $modx->getOption(\'seopro.core_path\', null, $modx->getOption(\'core_path\') . \'components/seopro/\') . \'model/seopro/\', $scriptProperties);
if (!($seoPro instanceof seoPro)) {
    return \'\';
}

$disabledTemplates = explode(\',\', $modx->getOption(\'seopro.disabledtemplates\', null, \'0\'));

switch ($modx->event->name) {
    case \'OnDocFormRender\':
        $template = (string)$resource->get(\'template\');
        $override = false;
        if (isset($_REQUEST[\'template\'])) {
            $template = (string)$_REQUEST[\'template\'];
            $override = true;
        }
        if (($override && $template === \'0\') || (!empty($template) && in_array($template, $disabledTemplates))) {
            break;
        }
        
        
        $currClassKey = $resource->get(\'class_key\');
        $strFields = $modx->getOption(\'seopro.fields\', null, \'pagetitle:70,longtitle:70,description:155,alias:2023,menutitle:2023\');
        $arrFields = array();
        if (is_array(explode(\',\', $strFields))) {
            foreach (explode(\',\', $strFields) as $field) {
                list($fieldName, $fieldCount) = explode(\':\', $field);
                $arrFields[$fieldName] = $fieldCount;
            }
        } else {
            return \'\';
        }

        $keywords = \'\';
        $modx->controller->addLexiconTopic(\'seopro:default\');
        $ctxKey = !empty($resource) ? $resource->get(\'context_key\') : $modx->getOption(\'default_context\');
        $ctx = $modx->getContext($ctxKey);
        if ($ctx) {
            $url = $ctx->getOption(\'site_url\', \'\', $modx->getOption(\'site_url\'));
        } else {
            $url = $modx->getOption(\'site_url\');
        }
        if ($mode == \'upd\') {
            if ($ctx) {
                if ($resource->get(\'id\') != $ctx->getOption(\'site_start\', \'\', $modx->getOption(\'site_start\'))) {
                    $url .= $resource->get(\'uri\');
                }
            } else {
                $url = $modx->makeUrl($resource->get(\'id\'), \'\', \'\', \'full\');
            }
            $url = str_replace(
                $resource->get(\'alias\'),
                \'<span id=\\"seopro-replace-alias\\">\' . $resource->get(\'alias\') . \'</span>\',
                $url
            );
            $seoKeywords = $modx->getObject(\'seoKeywords\', array(\'resource\' => $resource->get(\'id\')));
            if ($seoKeywords) {
                $keywords = $seoKeywords->get(\'keywords\');
            }
        }

        if ($_REQUEST[\'id\'] == $modx->getOption(\'site_start\')) {
            unset($arrFields[\'alias\']);
            unset($arrFields[\'menutitle\']);
        }


        $config = $seoPro->config;
        unset($config[\'resource\']);
        $modx->regClientStartupHTMLBlock(\'<script type="text/javascript">
        Ext.onReady(function() {
            seoPro.config = \' . $modx->toJSON($config) . \';
            seoPro.config.record = "\' . $keywords . \'";
            seoPro.config.values = {};
            seoPro.config.fields = "\' . implode(",", array_keys($arrFields)) . \'";
            seoPro.config.chars = \' . $modx->toJSON($arrFields) . \'
            seoPro.config.url = "\' . $url . \'";
        });
    </script>\');

        /* include CSS and JS*/
        $version = $modx->getVersionData();
        if($version[\'version\'] == 2 && $version[\'major_version\'] == 2){
            $modx->regClientCSS($seoPro->config[\'assetsUrl\'] . \'css/mgr.css\');
        }else{
            $modx->regClientCSS($seoPro->config[\'assetsUrl\'] . \'css/mgr23.css\');
        }
        $modx->regClientStartupScript($seoPro->config[\'assetsUrl\'] . \'js/mgr/seopro.js??v=\' . $modx->getOption(\'seopro.version\', null, \'v1.0.0\'));
        $modx->regClientStartupScript($seoPro->config[\'assetsUrl\'] . \'js/mgr/resource.js?v=\' . $modx->getOption(\'seopro.version\', null, \'v1.0.0\'));

        break;

    case \'OnDocFormSave\':
        $template = (string)$resource->get(\'template\');
        $override = false;
        if (isset($_REQUEST[\'template\'])) {
            $template = (string)$_REQUEST[\'template\'];
            $override = true;
        }
        if (($override && $template === \'0\') || (!empty($template) && in_array($template, $disabledTemplates))) {
            break;
        }
        $seoKeywords = $modx->getObject(\'seoKeywords\', array(\'resource\' => $resource->get(\'id\')));
        if (!$seoKeywords && isset($resource)) {
            $seoKeywords = $modx->newObject(\'seoKeywords\', array(\'resource\' => $resource->get(\'id\')));
        }
        if($seoKeywords){
            if (isset($_POST[\'keywords\'])){
                $seoKeywords->set(\'keywords\', trim($_POST[\'keywords\'], \',\'));
            } else {
                $seoKeywords->set(\'keywords\', \'\');
            }
            $seoKeywords->save();
        }
        break;

    case \'onResourceDuplicate\':
        $template = (string)$resource->get(\'template\');
        $override = false;
        if (isset($_REQUEST[\'template\'])) {
            $template = (string)$_REQUEST[\'template\'];
            $override = true;
        }
        if (($override && $template === \'0\') || (!empty($template) && in_array($template, $disabledTemplates))) {
            break;
        }

        $seoKeywords = $modx->getObject(\'seoKeywords\', array(\'resource\' => $resource->get(\'id\')));
        if (!$seoKeywords) {
            $seoKeywords = $modx->newObject(\'seoKeywords\', array(\'resource\' => $resource->get(\'id\')));
        }
        $newSeoKeywords = $modx->newObject(\'seoKeywords\');
        $newSeoKeywords->fromArray($seoKeywords->toArray());
        $newSeoKeywords->set(\'resource\', $newResource->get(\'id\'));
        $newSeoKeywords->save();
        break;

    case \'OnLoadWebDocument\':
        if ($modx->context->get(\'key\') == "mgr") {
            break;
        }
        $template = ($modx->resource->get(\'template\')) ? (string)$modx->resource->get(\'template\') : \'\';
        if (in_array($template, $disabledTemplates)) {
            break;
        }
        $seoKeywords = $modx->getObject(\'seoKeywords\', array(\'resource\' => $modx->resource->get(\'id\')));
        if ($seoKeywords) {
            $keyWords = $seoKeywords->get(\'keywords\');
            $modx->setPlaceholder(\'seoPro.keywords\', $keyWords);
        }
        // Render the meta title, based on system settings
        $titleFormat = $modx->getOption(\'seopro.title_format\');
        if (empty($titleFormat)) {
            $siteDelimiter = $modx->getOption(\'seopro.delimiter\', null, \'/\');
            $siteUseSitename = (boolean)$modx->getOption(\'seopro.usesitename\', null, true);
            $siteID = $modx->resource->get(\'id\');
            $siteName = $modx->getOption(\'site_name\');
            $longtitle = $modx->resource->get(\'longtitle\');
            $pagetitle = $modx->resource->get(\'pagetitle\');
            $seoProTitle = array();
            if ($siteID == $modx->getOption(\'site_start\')) {
                $seoProTitle[\'pagetitle\'] = !empty($longtitle) ? $longtitle : $siteName;
            } else {
                $seoProTitle[\'pagetitle\'] = !empty($longtitle) ? $longtitle : $pagetitle;
                if ($siteUseSitename) {
                    $seoProTitle[\'delimiter\'] = $siteDelimiter;
                    $seoProTitle[\'sitename\'] = $siteName;
                }
            }
            $title = implode(\' \', $seoProTitle);
        } else {
            $title = $modx->getOption(\'seopro.title_format\');
        }
        $modx->setPlaceholder(\'seoPro.title\', $title);
        break;
}',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    25 => 
    array (
      'id' => '25',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'StercSEO',
      'description' => 'Plugin to render SEO Tab and save all the data.',
      'editor_type' => '0',
      'category' => '27',
      'cache_type' => '0',
      'plugincode' => '/**
 * SEO Tab
 *
 * Copyright 2013 by Sterc internet & marketing <modx@sterc.nl>
 *
 * This file is part of SEO Tab.
 *
 * SEO Tab is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * SEO Tab is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * SEO Tab; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 *
 * @package stercseo
 */
/**
 * SEO Tab Plugin
 *
 *
 * Events:
 * OnDocFormPrerender,OnDocFormSave,OnHandleRequest,OnPageNotFound, OnResourceDuplicate, OnEmptyThrash, OnResourceBeforeSort
 *
 * @author Sterc internet & marketing <modx@sterc.nl>
 *
 * @package stercseo
 *
 */
$stercseo = $modx->getService(\'stercseo\', \'StercSEO\', $modx->getOption(\'stercseo.core_path\', null, $modx->getOption(\'core_path\').\'components/stercseo/\').\'model/stercseo/\', array());

if (!($stercseo instanceof StercSEO)) {
    return;
}

switch ($modx->event->name) {
    case \'OnDocFormPrerender\':
        if (!$stercseo->checkUserAccess()) {
            return;
        }

        $resource =& $modx->event->params[\'resource\'];
        if ($resource) {
            //First check if SEO Tab is allowed in this context
            if (!$stercseo->isAllowed($resource->get(\'context_key\'))) {
                return;
            }
            $properties = $resource->getProperties(\'stercseo\');
            $properties[\'searchable\'] = $resource->get(\'searchable\');
            $urls = $modx->getCollection(\'seoUrl\', array(\'resource\' => $resource->get(\'id\')));
        }

        if (empty($properties)) {
            $properties = array(
                \'index\' => $modx->getOption(\'stercseo.index\', null, \'1\'),
                \'follow\' => $modx->getOption(\'stercseo.follow\', null, \'1\'),
                \'sitemap\' => $modx->getOption(\'stercseo.sitemap\', null, \'1\'),
                \'priority\' => $modx->getOption(\'stercseo.priority\', null, \'0.5\'),
                \'changefreq\' => $modx->getOption(\'stercseo.changefreq\', null, \'weekly\'),
                \'searchable\' => $modx->getOption(\'search_default\', null, \'1\')
            );
        }
        $properties[\'urls\'] = \'\';
        // Fetch urls from seoUrl collection
        if ($urls && is_object($urls)) {
            foreach ($urls as $url) {
                $properties[\'urls\'][][\'url\'] = urldecode($url->get(\'url\'));
            }
        }

        $modx->regClientStartupHTMLBlock(\'<script type="text/javascript">
        Ext.onReady(function() {
            StercSEO.config = \'.$modx->toJSON($stercseo->config).\';
            StercSEO.config.connector_url = "\'.$stercseo->config[\'connectorUrl\'].\'";
            StercSEO.record = \'.$modx->toJSON($properties).\';
        });
        </script>\');
        $version = $modx->getVersionData();

        /* include CSS and JS*/
        if ($version[\'version\'] == 2 && $version[\'major_version\'] == 2) {
            $modx->regClientCSS($stercseo->config[\'cssUrl\'].\'stercseo.css\');
        }
        $modx->regClientStartupScript($stercseo->config[\'jsUrl\'].\'mgr/stercseo.js\');
        $modx->regClientStartupScript($stercseo->config[\'jsUrl\'].\'mgr/sections/resource.js\');
        $modx->regClientStartupScript($stercseo->config[\'jsUrl\'].\'mgr/widgets/resource.grid.js\');
        $modx->regClientStartupScript($stercseo->config[\'jsUrl\'].\'mgr/widgets/resource.vtabs.js\');

        //add lexicon
        $modx->controller->addLexiconTopic(\'stercseo:default\');

        break;

    case \'OnBeforeDocFormSave\':
        $oldResource = ($mode == \'upd\') ? $modx->getObject(\'modResource\', $resource->get(\'id\')) : $resource;
        if (!$stercseo->isAllowed($oldResource->get(\'context_key\'))) {
            return;
        }
        $properties = $oldResource->getProperties(\'stercseo\');

        if (isset($_POST[\'urls\'])) {
            $urls = $modx->fromJSON($_POST[\'urls\']);
            foreach ($urls as $url) {
                $check = $modx->getObject(\'seoUrl\', array( \'url\' => urlencode($url[\'url\']), \'resource\' => $oldResource->get(\'id\'), \'context_key\' => $oldResource->get(\'context_key\')));
                if (!$check) {
                    $redirect = $modx->newObject(\'seoUrl\');
                    $data = array(
                        \'url\' => urlencode($url[\'url\']),
                        \'resource\' => $oldResource->get(\'id\'),
                        \'context_key\' => $oldResource->get(\'context_key\'),
                    );
                    $redirect->fromArray($data);
                    $redirect->save();
                }
            }
        }

        if ($mode == \'upd\') {
            $newProperties = array(
                \'index\' => (isset($_POST[\'index\']) ? $_POST[\'index\'] : $properties[\'index\']),
                \'follow\' => (isset($_POST[\'follow\']) ? $_POST[\'follow\'] : $properties[\'follow\']),
                \'sitemap\' => (isset($_POST[\'sitemap\']) ? $_POST[\'sitemap\'] : $properties[\'sitemap\']),
                \'priority\' => (isset($_POST[\'priority\']) ? $_POST[\'priority\'] : $properties[\'priority\']),
                \'changefreq\' => (isset($_POST[\'changefreq\']) ? $_POST[\'changefreq\'] : $properties[\'changefreq\'])
            );
        } else {
            $newProperties = array(
                \'index\' => (isset($_POST[\'index\']) ? $_POST[\'index\'] : $modx->getOption(\'stercseo.index\', null, \'1\')),
                \'follow\' => (isset($_POST[\'follow\']) ? $_POST[\'follow\'] : $modx->getOption(\'stercseo.follow\', null, \'1\')),
                \'sitemap\' => (isset($_POST[\'sitemap\']) ? $_POST[\'sitemap\'] : $modx->getOption(\'stercseo.sitemap\', null, \'1\')),
                \'priority\' => (isset($_POST[\'priority\']) ? $_POST[\'priority\'] : $modx->getOption(\'stercseo.priority\', null, \'0.5\')),
                \'changefreq\' => (isset($_POST[\'changefreq\']) ? $_POST[\'changefreq\'] : $modx->getOption(\'stercseo.changefreq\', null, \'weekly\'))
            );
        }

        // If uri is changed or alias (with freeze uri off) has changed, add a new redirect
        if (($oldResource->get(\'uri\') != $resource->get(\'uri\') ||
                ($oldResource->get(\'uri_override\') == 0 && $oldResource->get(\'alias\') != $resource->get(\'alias\'))) &&
            $oldResource->get(\'uri\') != \'\') {
            $url = urlencode($modx->getOption(\'site_url\').$oldResource->get(\'uri\'));
            if (!$modx->getCount(\'seoUrl\', array(\'url\' => $url))) {
                $data = array(
                    \'url\' => $url,
                    \'resource\' => $resource->get(\'id\'),
                    \'context_key\' => $resource->get(\'context_key\'),
                );
                $redirect = $modx->newObject(\'seoUrl\');
                $redirect->fromArray($data);
                $redirect->save();
            }
            // Recursive set all children resources as redirects
            if ($modx->getOption(\'use_alias_path\')) {
                $resourceOldBasePath = $oldResource->getAliasPath($oldResource->get(\'alias\'), $oldResource->toArray() + array(\'isfolder\' => 1));
                $resourceNewBasePath = $resource->getAliasPath($resource->get(\'alias\'), $resource->toArray() + array(\'isfolder\' => 1));
                $childResources = $modx->getIterator(\'modResource\', array(
                    \'uri:LIKE\' => $resourceOldBasePath . \'%\',
                    \'uri_override\' => \'0\',
                    \'published\' => \'1\',
                    \'deleted\' => \'0\',
                    \'context_key\' => $resource->get(\'context_key\')
                ));
                foreach ($childResources as $childResource) {
                    $url = urlencode($modx->getOption(\'site_url\').$childResource->get(\'uri\'));
                    if (!$modx->getCount(\'seoUrl\', array(\'url\' => $url))) {
                        $data = array(
                            \'url\' => $url,
                            \'resource\' => $childResource->get(\'id\'),
                            \'context_key\' => $resource->get(\'context_key\'),
                        );
                        $redirect = $modx->newObject(\'seoUrl\');
                        $redirect->fromArray($data);
                        $redirect->save();
                    }
                }
            }
        }
        $resource->setProperties($newProperties, \'stercseo\');
        break;

    case \'OnDocFormSave\':
        if (!$stercseo->isAllowed($resource->context_key)) {
            return;
        }

        $url       = urlencode($modx->makeUrl($resource->id, $resource->context_key, \'\', \'full\'));
        $urlExists = $modx->getObject(\'seoUrl\', array(
            \'url\'         => $url,
            \'context_key\' => $resource->context_key
        ));

        if ($urlExists) {
            $modx->removeObject(\'seoUrl\', array(
                \'url\'         => $url,
                \'context_key\' => $resource->context_key
            ));
        }
        break;

    case \'OnLoadWebDocument\':
        if ($modx->resource) {
            if (!$stercseo->isAllowed($modx->resource->get(\'context_key\'))) {
                return;
            }
            $properties = $modx->resource->getProperties(\'stercseo\');
            if (empty($properties)) {
                // Properties not available
                // This means an this resource has nog SEO Tab properties, which means it is a pre-SEO Tab resource
                // Fallback to system defaults
                $properties = array(
                    \'index\' => $modx->getOption(\'stercseo.index\', null, 1),
                    \'follow\' => $modx->getOption(\'stercseo.follow\', null, 1)
                );
            }
            $metaContent = array(
                (int)$properties[\'index\'] ? \'index\' : \'noindex\',
                (int)$properties[\'follow\'] ? \'follow\' : \'nofollow\'
            );

            $modx->setPlaceholder(\'seoTab.robotsTag\', implode(\',\', $metaContent));
        }
        break;

    case \'OnPageNotFound\':
        $options      = array();
        $url          = ($_SERVER[\'HTTPS\'] ? \'https\' : \'http\').\'://\'.$_SERVER[\'HTTP_HOST\'].$_SERVER[\'REQUEST_URI\'];
        $convertedUrl = urlencode($url);

        $w = array(
            \'url\' => $convertedUrl
        );

        if ($modx->getOption(\'stercseo.context-aware-alias\', null, \'0\')) {
            $w[\'context_key\'] = $modx->context->key;
        }

        $alreadyExists = $modx->getObject(\'seoUrl\', $w);

        if (isset($alreadyExists) && ($modx->context->key !== $alreadyExists->get(\'context_key\'))) {
            $q = $modx->newQuery(\'modContextSetting\');
            $q->where(array(
                \'context_key\' => $alreadyExists->get(\'context_key\'),
                \'key\'         => \'site_url\'
            ));
            $q->prepare();

            $siteUrl = $modx->getObject(\'modContextSetting\', $q);
            if ($siteUrl) {
                $options[\'site_url\'] = $siteUrl->get(\'value\');
            }
        }

        if ($alreadyExists) {
            $url = $modx->makeUrl($alreadyExists->get(\'resource\'), $alreadyExists->get(\'context_key\'), \'\', \'full\', $options);

            $modx->sendRedirect($url, 0, \'REDIRECT_HEADER\', \'HTTP/1.1 301 Moved Permanently\');
        }
        break;

    case \'OnResourceBeforeSort\':
        list($sourceCtx, $resource) = explode(\'_\', $modx->getOption(\'source\', $_POST));
        list($targetCtx, $target) = explode(\'_\', $modx->getOption(\'target\', $_POST));
        switch ($modx->getOption(\'point\', $_POST)) {
            case \'above\':
            case \'below\':
                $tmpRes = $modx->getObject(\'modResource\', $target);
                if ($tmpRes) {
                    $target = $tmpRes->get(\'parent\');
                    unset($tmpRes);
                }
                break;
        }
        $oldResource = $modx->getObject(\'modResource\', $resource);
        $resource = $modx->getObject(\'modResource\', $resource);
        if ($oldResource && $resource) {
            $resource->set(\'parent\', $target);
            $resource->set(\'uri\', \'\');
            $uriChanged = false;
            if ($oldResource->get(\'uri\') != $resource->get(\'uri\') && $oldResource->get(\'uri\') != \'\') {
                $uriChanged = true;
            }

            // Recursive set redirects for drag/dropped resource, and its children (where uri_override is not set)
            if ($uriChanged && $modx->getOption(\'use_alias_path\')) {
                $oldResource->set(\'isfolder\', true);
                $resourceOldBasePath = $oldResource->getAliasPath(
                    $oldResource->get(\'alias\'),
                    $oldResource->toArray()
                );
                $resourceNewBasePath = $resource->getAliasPath(
                    $resource->get(\'alias\'),
                    $resource->toArray() + array(\'isfolder\' => 1)
                );
                $cond = $modx->newQuery(\'modResource\');
                $cond->where(array(
                    array(
                        \'uri:LIKE\' => $resourceOldBasePath . \'%\',
                        \'OR:id:=\' => $oldResource->id
                    ),
                    \'uri_override\' => \'0\',
                    \'published\' => \'1\',
                    \'deleted\' => \'0\',
                    \'context_key\' => $resource->get(\'context_key\')
                ));

                $ctx = $modx->getContext($resource->get(\'context_key\'));
                $site_url = $ctx->getOption(\'site_url\', \'\', $modx->getOption(\'site_url\'));

                $childResources = $modx->getIterator(\'modResource\', $cond);
                foreach ($childResources as $childResource) {
                    $url = urlencode($site_url . $childResource->get(\'uri\'));
                    if (!$modx->getCount(\'seoUrl\', array(\'url\' => $url))) {
                        $data = array(
                            \'url\' => $url,
                            \'resource\' => $childResource->get(\'id\'),
                            \'context_key\' => $targetCtx
                        );
                        $redirect = $modx->newObject(\'seoUrl\');
                        $redirect->fromArray($data);
                        $redirect->save();
                    }
                }
            } // endif $uriChanged
        } // endif $oldResource && $resource
        break;

    case \'OnResourceDuplicate\':
        if (!$stercseo->isAllowed($newResource->get(\'context_key\'))) {
            return;
        }
        $props = $newResource->getProperties(\'stercseo\');
        $newResource->setProperties($props, \'stercseo\');
        $newResource->save();
        break;

    case \'OnManagerPageBeforeRender\':
        if (!$stercseo->checkUserAccess()) {
            return;
        }
        // If migration status is false, show migrate alert message bar in manager
        if (!$stercseo->redirectMigrationStatus()) {
            $modx->regClientStartupHTMLBlock($stercseo->getChunk(\'migrate/alert\', array(\'message\' => $modx->lexicon(\'stercseo.migrate_alert\'))));
            $modx->regClientCSS($stercseo->config[\'cssUrl\'].\'migrate.css\');
        }
        break;

    case \'OnEmptyTrash\':
        if (count($ids) > 0) {
            foreach ($ids as $id) {
                $modx->removeCollection(\'seoUrl\', array(
                    \'resource\' => $id
                ));
            }
        }
}
return;',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    28 => 
    array (
      'id' => '28',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'CKEditor',
      'description' => 'CKEditor WYSIWYG editor plugin for MODx Revolution',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => '',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '1',
      'static_file' => 'ckeditor/elements/plugins/ckeditor.plugin.php',
    ),
    29 => 
    array (
      'id' => '29',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'Updater Notifier',
      'description' => 'This plugin manages the notifications for updates.',
      'editor_type' => '0',
      'category' => '31',
      'cache_type' => '0',
      'plugincode' => '$eventName = $modx->event->name;

switch($eventName) {

    case \'OnUpdaterNotify\':
    case \'OnUpdaterNotifyCore\':
    case \'OnUpdaterNotifyPackages\':
        $pfx = "[Updater Notifier] ";

        /* set the keyed system setting to current time */
        if (!function_exists(\'resetTimedSetting\')) {
            function resetTimedSetting(&$modx, $key, $value = \'\') {
                $digestSetting = $modx->getObject(\'modSystemSetting\', $key);
                if (!is_null($digestSetting)) {
                    $digestSetting->set(\'value\', strtotime(\'now\'));
                    $digestSetting->save();
                    $cacheRefreshOptions = array(\'system_settings\' => array());
                    $modx->cacheManager->refresh($cacheRefreshOptions);
                }
                //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] set time key \'" . $key . "\': " . $modx->getOption($key, null, \'???\'));
                return;
            }
        }
        /* set the keyed system setting to current time */
        if (!function_exists(\'resetLastSendSetting\')) {
            function resetLastSendSetting($key, $value, &$modx) {
                $digestSetting = $modx->getObject(\'modSystemSetting\', $key);
                if (!is_null($digestSetting)) {
                    $digestSetting->set(\'value\', $value);
                    $digestSetting->save();
                    $cacheRefreshOptions = array(\'system_settings\' => array());
                    $modx->cacheManager->refresh($cacheRefreshOptions);
                }
                //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] set lastsend key \'" . $key . "\': " . $modx->getOption($key, null, \'???\'));
                return;
            }
        }

        /* save retrieve uncached option */
        if (!function_exists(\'getSafeOption\')) {
            function getSafeOption(&$modx, $key) {
                $setting = $modx->getObject(\'modSystemSetting\',$key);
                /*
                if (is_null($setting)) {
                    $modx->log(modX::LOG_LEVEL_WARN, "[Updater] null value returned for setting: ".$key." Does it exist?");
                }
                */
                return ($setting) ? $setting->get(\'value\') : "";
            }
        }

        $debug = getSafeOption($modx, \'updater.debug\');
        if (!$debug && $eventName=="OnWebPageComplete") {
            return;
        }

        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Updater request called");

        if (!$modx->loadClass(\'Updater\', MODX_CORE_PATH . \'components/updater/model/\', true, true)) {
            return;
        }
        $updater = new Updater($modx);

        /* this event works as a semi-functional cron simulator */
        /* it is fired for any web or manager request */
        /* now we need the most restrictive and quickest filter first */

        /* Send core notifications */
        $coreNotifications = getSafeOption($modx,\'updater.send_core_notifications\');
        if ( $coreNotifications === "1") {

            $timestamp = getSafeOption($modx, \'updater.last_send_core_notification\');

            $last_sendcore_json = getSafeOption($modx, \'updater.last_send_core\');
            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} notify min every : " . $modx->getOption(\'updater.send_notification_hours\', null, 24) . " hours");

            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} elapsed hours since last core send check: " . round($elapsedHours, 2));

                /* check if time is over */
                if ($elapsedHours >= $modx->getOption(\'updater.send_notification_hours\', null, 24)) {
                    resetTimedSetting($modx, \'updater.last_send_core_notification\');


                    /* check if we need to refresh the core */
                    if ($updater->isCoreRefreshNeeded()) {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} need to refresh core data before sending email.");
                        $updater->refreshCoreVersion();
                        $updater->refreshCoreDownload();
                    }

                    /* check if the core is updateable */
                    if ( $updater->isCoreUpdateable() === true ) {

                        $last_send_core = $last_sendcore_json; //$modx->getOption(\'updater.last_send_core\', null, $updater->getCurrentCoreVersion());
                        $new_core = $updater->getLatestCoreVersion();

                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} last send: ".$last_send_core.", latest: ".$new_core);

                        if ( $debug || ( isset($last_send_core) && ($last_send_core==="" || $last_send_core!==$new_core))) {
                            resetLastSendSetting(\'updater.last_send_core\', $new_core, $modx);

                            if ($modx->getOption(\'updater.mail_format_html\', null, false) === "1") {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_coreinfo_html.tpl\');
                            } else {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_coreinfo.tpl\');
                            }

                            //$logodata = file_get_contents(MODX_MANAGER_PATH . \'templates/default/images/modx-icon-color.svg\');
                            $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");
                            $placeholders = array(
                                \'logodata\' => base64_encode($logodata),
                                \'core_update\' => $new_core,
                                \'core_current\' => $updater->getCurrentCoreVersion(),
                                \'core_changelog_url\' => "https://github.com/modxcms/revolution/blob/master/core/docs/changelog.txt",
                                \'core_download_url\' => $updater->constructCoreDownloadUrl(),
                            );

                            $modx->setPlaceholders($placeholders);
                            $modx->getParser()->processElementTags(\'\', $chunk, true);

                            $subject = "Core update available for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                            $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                            $fromName = "MODX System Notifier (Core)";

                            $time = microtime(true);
                            $modx->getService(\'mail\', \'mail.modPHPMailer\');

                            $modx->mail->set(modMail::MAIL_BODY, $chunk);
                            $modx->mail->set(modMail::MAIL_FROM, $from);
                            $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                            $modx->mail->set(modMail::MAIL_SUBJECT, $subject);


                            // TODO: walk through users here
                            $modx->mail->address(\'to\', $modx->getOption(\'updater.core_notifications_mail\'));
                            $modx->mail->setHTML($modx->getOption(\'updater.mail_format_html\', null, false) === "1");

                            if ($debug) $modx->log(4,$pfx." intermediate time for setting up core mail: ".round(microtime(true)-$time,2));

                            if (!$modx->mail->send()) {
                                $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                            } else {
                                $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send core data to " . $modx->getOption(\'updater.core_notifications_mail\'));
                            }
                            if ($debug) $modx->log(4,$pfx." intermediate time for sending core mail: ".round(microtime(true)-$time,2));

                            $modx->mail->reset();
                            if ($debug) $modx->log(4,$pfx." final time for sending core mail: ".round(microtime(true)-$time,2));

                        } else {
                            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} No need to send core data.");
                        }
                    }
                }
            }
        }


        /* Send package notifications */
        $packageNotifications = getSafeOption($modx,\'updater.send_package_notifications\');
        if ($packageNotifications==="1") {

            $timestamp = getSafeOption($modx,\'updater.last_send_package_notification\');

            $last_sendpackages_json = getSafeOption($modx, \'updater.last_send_packages\');
            // if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] notify min every : ".$modx->getOption(\'updater.send_notification_hours\',null,24)." hours");

            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                // if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] elapsed hours since last check: ".round($elapsedHours,2));

                /* check if time is over */
                if ($elapsedHours >= $modx->getOption(\'updater.send_notification_hours\',null,24)) {
                    $time = microtime(true);

                    /*
                        until now this strange reformatting is necessary because package controller
                        returns nonsense and we did not touch it in updater class
                    */
                    $package_names_update = array();
                    $tmp = $updater->getPackagesUpdateList();
                    if (isset($tmp) && !is_null($tmp)) {
                        $packages_names_update  = array_map(
                            function($v) {
                                return ($v[0][\'name\']." > ".$v[0][\'signature\']);
                            }, $tmp
                        );
                    } else {
                        return;
                    }

                    $packages_names_install = array();
                    $tmp = $updater->getPackagesList();
                    if (isset($tmp) && !is_null($tmp)) {
                        $packages_names_install = array_map(
                            function ($v) {
                                return ($v[\'package_name\'] . ": " . $v[\'signature\']);
                            },
                            array_filter(
                                $tmp,
                                function ($v) {
                                    return $v[\'installed\'] == "";
                                }
                            )
                        );
                    }

                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages to install: ".json_encode($packages_names_install));
                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages to update: ".json_encode($packages_names_update));


                    if (sizeof($packages_names_install)+sizeof($packages_names_update) > 0) {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} there are updates to notify!");
                        resetTimedSetting($modx, \'updater.last_send_package_notification\');

                        $store_send_packages = array_merge(
                            array_map(
                                function($v) {
                                    return array( \'name\' => $v[0][\'name\'], \'installed\'=>$v[0][\'installed\'], \'update\' => $v[0][\'signature\']);
                                },
                                $updater->getPackagesUpdateList()
                            ),
                            array_map(
                                function($v) {
                                    return array( \'name\' => $v[\'name\'], \'installed\'=>\'previous\', \'update\' => $v[\'signature\']);
                                },
                                array_filter($updater->getPackagesList(), function($v) {  return $v[\'installed\']==""; })
                            )
                        );


                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} data: ".json_encode($store_send_packages));
                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages_names_update: ".json_encode($packages_names_update));
                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages_names_install: ".json_encode($packages_names_install));

                        $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");

                        $placeholders = array(
                            \'logodata\' => base64_encode($logodata),
                            \'logoformat\' => \'\',
                            \'updater.packages_names_install\' => \'\'.implode("\\n",$packages_names_install),
                            \'updater.packages_names_update\' => \'\'.implode("\\n",$packages_names_update),
                        );

                        $store_send_packages_json = json_encode(array_values($store_send_packages));

                        /* only send mail if the packages list differs from last send packages list */
                        if ($store_send_packages_json !== $last_sendpackages_json || $debug) {
                            resetLastSendSetting(\'updater.last_send_packages\', $store_send_packages_json, $modx);

                            if ($modx->getOption(\'updater.mail_format_html\',null,false)==="1") {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_packageinfo_html.tpl\');
                            } else {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_packageinfo.tpl\');
                            }

                            $modx->setPlaceholders($placeholders);
                            $modx->getParser()->processElementTags(\'\', $chunk, true);

                            $subject = "Package update notification for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                            $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                            $fromName = "MODX System Notifier (Packages)";

                            $time=microtime(true);

                            $modx->getService(\'mail\', \'mail.modPHPMailer\');
                            $modx->mail->set(modMail::MAIL_BODY, $chunk);
                            $modx->mail->set(modMail::MAIL_FROM, $from);
                            $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                            $modx->mail->set(modMail::MAIL_SUBJECT, $subject);
                            // TODO: walk through users here
                            $modx->mail->address(\'to\', $modx->getOption(\'updater.package_notifications_mail\'));
                            $modx->mail->setHTML($modx->getOption(\'updater.mail_format_html\',null,false)==="1");

                            if (!$modx->mail->send()) {
                                $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                            } else {
                                $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send package data to ".$modx->getOption(\'updater.package_notifications_mail\'));
                            }

                            $modx->mail->reset();
                            if ($debug) $modx->log(4,$pfx." time for sending packages mail: ".round(microtime(true)-$time,2));


                        } else {
                            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} There are updates available, but this notification was already send: ".$store_send_packages_json);
                        }

                    }
                }
            } else {
                resetTimedSetting($modx, \'updater.last_send_package_notification\');
            }
        }

        /* Send digest */
        if ($modx->getOption(\'updater.send_version_digest_user\',null,false)==="1") {
            $timestamp = $modx->getOption(\'updater.last_send_version_digest\', null, \'\');
            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                //$modx->log(modX::LOG_LEVEL_INFO, "[updater-notifier] time elapsed: " . $elapsedHours . " h");

                /* check if digest is over */
                if ($elapsedHours > $modx->getOption(\'updater.send_version_digest_hours\') || $debug) {
                    // reset the timestamp here to prevent multiple mails
                    resetTimedSetting($modx, \'updater.last_send_version_digest\');

                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} SEND DIGEST.");

                    $packageList = array();
                    $packageList = $updater->getPackagesList();

                    $coreMessage = "You are up to date with version " . $updater->getCurrentCoreVersion();
                    $coreMessageHTML = "<div style=\'color:green\'>" . $coreMessage . "</div>";
                    if ($updater->isCoreUpdateable()) {
                        $coreMessage = "An UPDATE to version " . $updater->getLatestCoreVersion() . " is available!";
                        $coreMessageHTML = "<div style=\'color:red\'>" . $coreMessage . "</div>";
                        $coreMessage = "*** " . $coreMessage . " ***";
                    }

                    $packages_list = str_pad(\'Package\', 32) . " | " . str_pad(\'Version signature\', 40) . " | " . "update?\\n";
                    $packages_list .= str_pad("", strlen($packages_list), \'-\') . "\\n";
                    $updates_list = $updater->getPackagesUpdateList();
                    $updates = 0;
                    $installed = 0;
                    foreach ($updater->getPackagesList() as $p) {
                        $packages_list .= str_pad($p[\'name\'], 32) . " | " . str_pad($p[\'signature\'], 40);
                        if ($p[\'updateable\'] === true) {
                            $packages_list .= " | UPDATE AVAILABLE TO " . $updates_list[$p[\'signature\']][0][\'version\'];

                            $updates++;
                        } else {
                            if ($p[\'installed\'] == "") {
                                $packages_list .= " | Installation pending";
                                $installed++;
                            } else {
                                $packages_list .= " |";
                            }
                        }
                        $packages_list .= "\\n";
                    }

                    $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");
                    //$logodata = file_get_contents(MODX_MANAGER_PATH . \'templates/default/images/modx-icon-color.svg\');

                    $placeholders = array(
                        \'logodata\' => base64_encode($logodata),
                        \'core_message\' => $coreMessage,
                        \'packages_list\' => $packages_list,
                        //\'packages_updates\' => json_encode($updates_list),
                        \'update_core\' => ($updater->getLatestCoreVersion() !== $updater->getCurrentCoreVersion()) ? $updater->getLatestCoreVersion() : \'\',
                        \'installable\' => $installed,
                        \'updateable\' => $updates
                    );

                    $placeholders[\'packages_message\'] = "";
                    if ($updates > 0) {
                        $placeholders[\'updater.packages_message\'] = "" . $updates . " packages can be updated!!!\\n";
                    } else {
                        $placeholders[\'packages_message\'] = "All packages are up to date.\\n";
                    }
                    if ($installed > 0) {
                        $placeholders[\'packages_message\'] .= "" . $installed . " packages are not installed yet.";
                    }

                    // send the digest
                    //$message = $modx->getChunk(\'updater.mail_version_digest.tpl\', $placeholders);
                    $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_text.tpl\');
                    $modx->setPlaceholders($placeholders);
                    $modx->getParser()->processElementTags(\'\', $chunk, true);
                    $message = $chunk;

                    $subject = "System notification for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                    $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                    $fromName = "MODX System Notifier";

                    $time=microtime(true);

                    $modx->getService(\'mail\', \'mail.modPHPMailer\');
                    $modx->mail->set(modMail::MAIL_BODY, $message);
                    $modx->mail->set(modMail::MAIL_FROM, $from);
                    $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                    $modx->mail->set(modMail::MAIL_SUBJECT, $subject);
                    // TODO: walk through users here
                    $modx->mail->address(\'to\', $modx->getOption(\'updater.core_notifications_mail\'));
                    $modx->mail->setHTML(false);

                    if (!$modx->mail->send()) {
                        $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                    } else {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send digest to ".$modx->getOption(\'updater.core_notifications_mail\'));
                    }

                    $modx->mail->reset();
                    if ($debug) $modx->log(4,$pfx." time for sending digest mail: ".round(microtime(true)-$time,2));
                }
            } else {
                /* no timestamp in system settings? */
                if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} no time stamp in system settings found.");
                resetTimedSetting($modx, \'updater.last_send_version_digest\');
            }
        }
        break;

}
return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    30 => 
    array (
      'id' => '30',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'Updater Cache Observer',
      'description' => 'This plugin observes package changes and refreshes Updaters caches accordingly.',
      'editor_type' => '0',
      'category' => '31',
      'cache_type' => '0',
      'plugincode' => '$eventName = $modx->event->name;
switch($eventName) {

    case \'OnCacheUpdate\':

        /* only trigger a refresh if packages or system settings are changed */
        $packageKey = $modx->getOption(\'cache_packages_key\', null, \'packages\');
        $settingsKey = $modx->getOption(\'cache_system_settings_key\', null, \'system_settings\');

        if ( isset($results[ $settingsKey ]) && $results[$settingsKey]) {
            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater] clearing internal caches.");
            //$modx->log(modX::LOG_LEVEL_WARN, "[Updater] " . print_r($results, true));

            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater]  clear packages cache");
            $result1 = $modx->cacheManager->clean(array(xPDO::OPT_CACHE_KEY => \'updater-packages\'));

            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater]  clear core cache");
            $result2 = $modx->cacheManager->clean(array(xPDO::OPT_CACHE_KEY => \'updater-core\'));

            if ($result1 && $result2) {
                //$modx->log(modX::LOG_LEVEL_INFO, "[Updater] successfully cleared Updaters\' internal caches due to changed system settings/cache clear");
            } else {
                //$modx->log(modX::LOG_LEVEL_WARN, "[Updater] There was an error clearing Updaters\' internal caches.");
            }
            break;
        }

        if ( isset($results[ $packageKey ]) && $results[$packageKey]) {
            $modx->log(modX::LOG_LEVEL_INFO, "[Updater] packages have been changed, clearing updater cache.");
            $cacheOptions = array( xPDO::OPT_CACHE_KEY => \'updater-packages\' );
            $result = $modx->cacheManager->clean($cacheOptions);
            //$modx->log(modX::LOG_LEVEL_INFO, "[Updater] clean result: ".$result);
            //$modx->log(modX::LOG_LEVEL_INFO, "[Updater] Successfully cleared updater cache after package change.");
        }

        break;

    default:
        break;
}
return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    31 => 
    array (
      'id' => '31',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'Updater Cron',
      'description' => 'This plugin simulates a cronlike scheduler and is triggered by web and manager page requests.',
      'editor_type' => '0',
      'category' => '31',
      'cache_type' => '0',
      'plugincode' => '/*
    This plugin implements a simple but effective cron mechanism to refresh updaters data.

    How does it work?
        - cronlike schedule is triggered by a web page request
        - on the init of the request the plugin is triggered
        - the file modification time of an (empty) file is checked
            (this is done way faster than to check a modx option object, which is generally not intended to change frequently,
             measurement on the same machine: get system setting ~0.01s, filemtime ~0.0005s !!!)
        - if the last saved time compared to the current time is greater than a preset interval,
            the plugin injects a tiny javascript to the webpage
        - the javascript is called async and finally triggers the refresh of the (sometimes time-consuming) updater refresh

    Benefits:
        This way there is no measureable time gap for your webpage to be delivered (instead of directly refreshing the
        updater data), so visitors and your websites performance will not be affected, even if the updater task runs a long time
        or runs into a timeout.
        There is no need to setup a cronjob for this (which may not be possible due to the environment or the client using updater).

    Drawbacks:
        This only works if enough visitors with js enabled browser frequently visit your webpage. If you only have 1 hit per month,
        the updaters cache will be refreshed once per month as well, regardless of the interval. In this case
        it is a better idea to call the script /connectors/updater.cron.php with a cronjob instead.
*/

$eventName = $modx->event->name;
switch($eventName) {
    case "OnManagerPageInit":
    case "OnWebPageInit":
        $key = \'updater.lastcroninject\';

        //$t = microtime(true);
        $lastInjectTime = "";
        if (file_exists(MODX_CORE_PATH.\'cache/UPDATER_CRON\')) {
            $lastInjectTime = filemtime(MODX_CORE_PATH.\'cache/UPDATER_CRON\');
        }

        $currentTime = time();
        if (is_null($lastInjectTime) || $lastInjectTime == \'\') {
            $lastInjectTime = 0;
        }

        /*
         * Check if time interval is reached. The interval is hardcoded to prevent unneccessary option lookups again.
         * Current Interval: 3600 = 1 hour
         *
         * That does not necessarily mean, that every interval an update lookup is done. This only triggers
         * following up events, the event handlers themselves have cache times to stick to.
         * This interval only ensures, that at least every hour the followups are checked.
         */

        if (($currentTime - $lastInjectTime) >= 3600) {
            //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater cron-plugin] elapsed seconds since last core refresh: " . ($currentTime - $lastInjectTime) ." - we need to refresh!");

            /* adjust the last saved time stamp */
            touch(MODX_CORE_PATH.\'cache/UPDATER_CRON\');

            /* inject javascript into web page */
            //$modx->log(4, "[updater cron-plugin] injecting cron script at time ".$currentTime);
            //$modx->regClientScript(MODX_ASSETS_URL . \'components/updater/js/updater.croninject.js\');

            /*
                using regClientScript is not the favoured way here: it adds a roundtrip and does not give the
                chance to call the script async!
                Instead we will inject our tiny script code here direcly!
                    - the code could be inlined here, but is not for future development
            */
            $script  = "<script type=\'text/javascript\'>";
            $script .= "var U=\'".MODX_CONNECTORS_URL."updater/updater.cron.php\';\\n";
            $script .= file_get_contents( MODX_ASSETS_PATH . \'components/updater/js/updater.croninject.js\');
            $script .= "</script>";

            $modx->regClientHTMLBlock($script);
        }
}
return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    32 => 
    array (
      'id' => '32',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'Updater Refresh',
      'description' => 'This plugin handles refresh events triggered e.g. by the cron handler.',
      'editor_type' => '0',
      'category' => '31',
      'cache_type' => '0',
      'plugincode' => '$eventName = $modx->event->name;

switch($eventName) {
    case \'OnUpdaterCoreRefresh\':
    case \'OnUpdaterPackagesRefresh\':
        /* just get the updater object and refresh core and extras */
        /* flag to only refresh if caches are invalid! */

        $debug = $modx->getOption(\'updater.debug\', null, false);

        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[Updater] refresh plugin was triggered.");

        /* try to get the Updater object */
        if (!$modx->loadClass(\'Updater\', MODX_CORE_PATH . \'components/updater/model/\', true, true)) {
            return;
        }

        /*
            instead of handling these events we can also add js triggers to our pages which
            call the refresh connector directly.
        */

        $updater = new Updater($modx, array());

        if ($eventName=="OnUpdaterCoreRefresh") {
            if ($updater->isCoreRefreshNeeded()) {
                $updater->refreshCoreVersion();
                $updater->refreshCoreDownload();
                $updater->refreshMUIFromURL();
            }
        }
        if ($eventName=="OnUpdaterPackagesRefresh") {
            if ($updater->isPackageRefreshNeeded()) {
                $updater->refreshPackageData();
            }
        }
}

return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    33 => 
    array (
      'id' => '33',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'TinyMCE',
      'description' => 'TinyMCE 4.3.4-pl plugin for MODx Revolution',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => '/**
 * TinyMCE RichText Editor Plugin
 *
 * Events: OnRichTextEditorInit, OnRichTextEditorRegister,
 * OnBeforeManagerPageInit, OnRichTextBrowserInit
 *
 * @author Jeff Whitfield <jeff@collabpad.com>
 * @author Shaun McCormick <shaun@collabpad.com>
 *
 * @var modX $modx
 * @var array $scriptProperties
 *
 * @package tinymce
 * @subpackage build
 */
if ($modx->event->name == \'OnRichTextEditorRegister\') {
    $modx->event->output(\'TinyMCE\');
    return;
}
require_once $modx->getOption(\'tiny.core_path\',null,$modx->getOption(\'core_path\').\'components/tinymce/\').\'tinymce.class.php\';
$tiny = new TinyMCE($modx,$scriptProperties);

$useEditor = $tiny->context->getOption(\'use_editor\',false);
$whichEditor = $tiny->context->getOption(\'which_editor\',\'\');

/* Handle event */
switch ($modx->event->name) {
    case \'OnRichTextEditorInit\':
        if ($useEditor && $whichEditor == \'TinyMCE\') {
            unset($scriptProperties[\'chunk\']);
            if (isset($forfrontend) || $modx->context->get(\'key\') != \'mgr\') {
                $def = $tiny->context->getOption(\'cultureKey\',$tiny->context->getOption(\'manager_language\',\'en\'));
                $tiny->properties[\'language\'] = $modx->getOption(\'fe_editor_lang\',array(),$def);
                $tiny->properties[\'frontend\'] = true;
                unset($def);
            }
            /* commenting these out as it causes problems with richtext tvs */
            //if (isset($scriptProperties[\'resource\']) && !$resource->get(\'richtext\')) return;
            //if (!isset($scriptProperties[\'resource\']) && !$modx->getOption(\'richtext_default\',null,false)) return;
            $tiny->setProperties($scriptProperties);
            $html = $tiny->initialize();
            $modx->event->output($html);
            unset($html);
        }
        break;
    case \'OnRichTextBrowserInit\':
        if ($useEditor && $whichEditor == \'TinyMCE\') {
            $inRevo20 = (boolean)version_compare($modx->version[\'full_version\'],\'2.1.0-rc1\',\'<\');
            $modx->getVersionData();
            $source = $tiny->context->getOption(\'default_media_source\',null,1);
            
            $modx->controller->addHtml(\'<script type="text/javascript">var inRevo20 = \'.($inRevo20 ? 1 : 0).\';MODx.source = "\'.$source.\'";</script>\');
            
            $modx->controller->addJavascript($tiny->config[\'assetsUrl\'].\'jscripts/tiny_mce/tiny_mce_popup.js\');
            if (file_exists($tiny->config[\'assetsPath\'].\'jscripts/tiny_mce/langs/\'.$tiny->properties[\'language\'].\'.js\')) {
                $modx->controller->addJavascript($tiny->config[\'assetsUrl\'].\'jscripts/tiny_mce/langs/\'.$tiny->properties[\'language\'].\'.js\');
            } else {
                $modx->controller->addJavascript($tiny->config[\'assetsUrl\'].\'jscripts/tiny_mce/langs/en.js\');
            }
            $modx->controller->addJavascript($tiny->config[\'assetsUrl\'].\'tiny.browser.js\');
            $modx->event->output(\'Tiny.browserCallback\');
        }
        return \'\';
        break;

   default: break;
}
return;',
      'locked' => '0',
      'properties' => 'a:39:{s:22:"accessibility_warnings";a:7:{s:4:"name";s:22:"accessibility_warnings";s:4:"desc";s:315:"If this option is set to true some accessibility warnings will be presented to the user if they miss specifying that information. This option is set to true by default, since we should all try to make this world a better place for disabled people. But if you are annoyed with the warnings, set this option to false.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:23:"apply_source_formatting";a:7:{s:4:"name";s:23:"apply_source_formatting";s:4:"desc";s:229:"This option enables you to tell TinyMCE to apply some source formatting to the output HTML code. With source formatting, the output HTML code is indented and formatted. Without source formatting, the output HTML is more compact. ";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:15:"button_tile_map";a:7:{s:4:"name";s:15:"button_tile_map";s:4:"desc";s:338:"If this option is set to true TinyMCE will use tiled images instead of individual images for most of the editor controls. This produces faster loading time since only one GIF image needs to be loaded instead of a GIF for each individual button. This option is set to false by default since it doesn\'t work with some DOCTYPE declarations. ";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:0;s:7:"lexicon";N;s:4:"area";s:0:"";}s:7:"cleanup";a:7:{s:4:"name";s:7:"cleanup";s:4:"desc";s:331:"This option enables or disables the built-in clean up functionality. TinyMCE is equipped with powerful clean up functionality that enables you to specify what elements and attributes are allowed and how HTML contents should be generated. This option is set to true by default, but if you want to disable it you may set it to false.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:18:"cleanup_on_startup";a:7:{s:4:"name";s:18:"cleanup_on_startup";s:4:"desc";s:135:"If you set this option to true, TinyMCE will perform a HTML cleanup call when the editor loads. This option is set to false by default.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:0;s:7:"lexicon";N;s:4:"area";s:0:"";}s:22:"convert_fonts_to_spans";a:7:{s:4:"name";s:22:"convert_fonts_to_spans";s:4:"desc";s:348:"If you set this option to true, TinyMCE will convert all font elements to span elements and generate span elements instead of font elements. This option should be used in order to get more W3C compatible code, since font elements are deprecated. How sizes get converted can be controlled by the font_size_classes and font_size_style_values options.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:23:"convert_newlines_to_brs";a:7:{s:4:"name";s:23:"convert_newlines_to_brs";s:4:"desc";s:128:"If you set this option to true, newline characters codes get converted into br elements. This option is set to false by default.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:0;s:7:"lexicon";N;s:4:"area";s:0:"";}s:12:"convert_urls";a:7:{s:4:"name";s:12:"convert_urls";s:4:"desc";s:495:"This option enables you to control whether TinyMCE is to be clever and restore URLs to their original values. URLs are automatically converted (messed up) by default because the built-in browser logic works this way. There is no way to get the real URL unless you store it away. If you set this option to false it will try to keep these URLs intact. This option is set to true by default, which means URLs will be forced to be either absolute or relative depending on the state of relative_urls.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:11:"dialog_type";a:7:{s:4:"name";s:11:"dialog_type";s:4:"desc";s:246:"This option enables you to specify how dialogs/popups should be opened. Possible values are "window" and "modal", where the window option opens a normal window and the dialog option opens a modal dialog. This option is set to "window" by default.";s:4:"type";s:4:"list";s:7:"options";a:2:{i:0;a:2:{i:0;s:6:"window";s:4:"text";s:6:"Window";}i:1;a:2:{i:0;s:5:"modal";s:4:"text";s:5:"Modal";}}s:5:"value";s:6:"window";s:7:"lexicon";N;s:4:"area";s:0:"";}s:14:"directionality";a:7:{s:4:"name";s:14:"directionality";s:4:"desc";s:261:"This option specifies the default writing direction. Some languages (Like Hebrew, Arabic, Urdu...) write from right to left instead of left to right. The default value of this option is "ltr" but if you want to use from right to left mode specify "rtl" instead.";s:4:"type";s:4:"list";s:7:"options";a:2:{i:0;a:2:{s:5:"value";s:3:"ltr";s:4:"text";s:13:"Left to Right";}i:1;a:2:{s:5:"value";s:3:"rtl";s:4:"text";s:13:"Right to Left";}}s:5:"value";s:3:"ltr";s:7:"lexicon";N;s:4:"area";s:0:"";}s:14:"element_format";a:7:{s:4:"name";s:14:"element_format";s:4:"desc";s:210:"This option enables control if elements should be in html or xhtml mode. xhtml is the default state for this option. This means that for example &lt;br /&gt; will be &lt;br&gt; if you set this option to "html".";s:4:"type";s:4:"list";s:7:"options";a:2:{i:0;a:2:{s:5:"value";s:5:"xhtml";s:4:"text";s:5:"XHTML";}i:1;a:2:{s:5:"value";s:4:"html";s:4:"text";s:4:"HTML";}}s:5:"value";s:5:"xhtml";s:7:"lexicon";N;s:4:"area";s:0:"";}s:15:"entity_encoding";a:7:{s:4:"name";s:15:"entity_encoding";s:4:"desc";s:70:"This option controls how entities/characters get processed by TinyMCE.";s:4:"type";s:4:"list";s:7:"options";a:4:{i:0;a:2:{s:5:"value";s:0:"";s:4:"text";s:4:"None";}i:1;a:2:{s:5:"value";s:5:"named";s:4:"text";s:5:"Named";}i:2;a:2:{s:5:"value";s:7:"numeric";s:4:"text";s:7:"Numeric";}i:3;a:2:{s:5:"value";s:3:"raw";s:4:"text";s:3:"Raw";}}s:5:"value";s:0:"";s:7:"lexicon";N;s:4:"area";s:0:"";}s:16:"force_p_newlines";a:7:{s:4:"name";s:16:"force_p_newlines";s:4:"desc";s:147:"This option enables you to disable/enable the creation of paragraphs on return/enter in Mozilla/Firefox. The default value of this option is true. ";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:22:"force_hex_style_colors";a:7:{s:4:"name";s:22:"force_hex_style_colors";s:4:"desc";s:277:"This option enables you to control TinyMCE to force the color format to use hexadecimal instead of rgb strings. It converts for example "color: rgb(255, 255, 0)" to "#FFFF00". This option is set to true by default since otherwice MSIE and Firefox would differ in this behavior.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:6:"height";a:7:{s:4:"name";s:6:"height";s:4:"desc";s:38:"Sets the height of the TinyMCE editor.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:5:"400px";s:7:"lexicon";N;s:4:"area";s:0:"";}s:11:"indentation";a:7:{s:4:"name";s:11:"indentation";s:4:"desc";s:139:"This option allows specification of the indentation level for indent/outdent buttons in the UI. This defaults to 30px but can be any value.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:4:"30px";s:7:"lexicon";N;s:4:"area";s:0:"";}s:16:"invalid_elements";a:7:{s:4:"name";s:16:"invalid_elements";s:4:"desc";s:163:"This option should contain a comma separated list of element names to exclude from the content. Elements in this list will removed when TinyMCE executes a cleanup.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:0:"";s:7:"lexicon";N;s:4:"area";s:0:"";}s:6:"nowrap";a:7:{s:4:"name";s:6:"nowrap";s:4:"desc";s:212:"This nowrap option enables you to control how whitespace is to be wordwrapped within the editor. This option is set to false by default, but if you enable it by setting it to true editor contents will never wrap.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:0;s:7:"lexicon";N;s:4:"area";s:0:"";}s:15:"object_resizing";a:7:{s:4:"name";s:15:"object_resizing";s:4:"desc";s:148:"This option gives you the ability to turn on/off the inline resizing controls of tables and images in Firefox/Mozilla. These are enabled by default.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:12:"path_options";a:7:{s:4:"name";s:12:"path_options";s:4:"desc";s:119:"Sets a group of options. Note: This will override the relative_urls, document_base_url and remove_script_host settings.";s:4:"type";s:9:"textfield";s:7:"options";a:3:{i:0;a:2:{s:5:"value";s:11:"docrelative";s:4:"text";s:17:"Document Relative";}i:1;a:2:{s:5:"value";s:12:"rootrelative";s:4:"text";s:13:"Root Relative";}i:2;a:2:{s:5:"value";s:11:"fullpathurl";s:4:"text";s:13:"Full Path URL";}}s:5:"value";s:11:"docrelative";s:7:"lexicon";N;s:4:"area";s:0:"";}s:28:"plugin_insertdate_dateFormat";a:7:{s:4:"name";s:28:"plugin_insertdate_dateFormat";s:4:"desc";s:53:"Formatting of dates when using the InsertDate plugin.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:8:"%Y-%m-%d";s:7:"lexicon";N;s:4:"area";s:0:"";}s:28:"plugin_insertdate_timeFormat";a:7:{s:4:"name";s:28:"plugin_insertdate_timeFormat";s:4:"desc";s:53:"Formatting of times when using the InsertDate plugin.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:8:"%H:%M:%S";s:7:"lexicon";N;s:4:"area";s:0:"";}s:12:"preformatted";a:7:{s:4:"name";s:12:"preformatted";s:4:"desc";s:231:"If you enable this feature, whitespace such as tabs and spaces will be preserved. Much like the behavior of a &lt;pre&gt; element. This can be handy when integrating TinyMCE with webmail clients. This option is disabled by default.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:13:"relative_urls";a:7:{s:4:"name";s:13:"relative_urls";s:4:"desc";s:231:"If this option is set to true, all URLs returned from the file manager will be relative from the specified document_base_url. If it is set to false all URLs will be converted to absolute URLs. This option is set to true by default.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:17:"remove_linebreaks";a:7:{s:4:"name";s:17:"remove_linebreaks";s:4:"desc";s:531:"This option controls whether line break characters should be removed from output HTML. This option is enabled by default because there are differences between browser implementations regarding what to do with white space in the DOM. Gecko and Safari place white space in text nodes in the DOM. IE and Opera remove them from the DOM and therefore the line breaks will automatically be removed in those. This option will normalize this behavior when enabled (true) and all browsers will have a white-space-stripped DOM serialization.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:0;s:7:"lexicon";N;s:4:"area";s:0:"";}s:18:"remove_script_host";a:7:{s:4:"name";s:18:"remove_script_host";s:4:"desc";s:221:"If this option is enabled the protocol and host part of the URLs returned from the file manager will be removed. This option is only used if the relative_urls option is set to false. This option is set to true by default.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:20:"remove_trailing_nbsp";a:7:{s:4:"name";s:20:"remove_trailing_nbsp";s:4:"desc";s:392:"This option enables you to specify that TinyMCE should remove any traling &nbsp; characters in block elements if you start to write inside them. Paragraphs are default padded with a &nbsp; and if you write text into such paragraphs the space will remain. Setting this option to true will remove the space. This option is set to false by default since the cursor jumps a bit in Gecko browsers.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:0;s:7:"lexicon";N;s:4:"area";s:0:"";}s:4:"skin";a:7:{s:4:"name";s:4:"skin";s:4:"desc";s:330:"This option enables you to specify what skin you want to use with your theme. A skin is basically a CSS file that gets loaded from the skins directory inside the theme. The advanced theme that TinyMCE comes with has two skins, these are called "default" and "o2k7". We added another skin named "cirkuit" that is chosen by default.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:7:"cirkuit";s:7:"lexicon";N;s:4:"area";s:0:"";}s:12:"skin_variant";a:7:{s:4:"name";s:12:"skin_variant";s:4:"desc";s:403:"This option enables you to specify a variant for the skin, for example "silver" or "black". "default" skin does not offer any variant, whereas "o2k7" default offers "silver" or "black" variants to the default one. For the "cirkuit" skin there\'s one variant named "silver". When creating a skin, additional variants may also be created, by adding ui_[variant_name].css files alongside the default ui.css.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:0:"";s:7:"lexicon";N;s:4:"area";s:0:"";}s:20:"table_inline_editing";a:7:{s:4:"name";s:20:"table_inline_editing";s:4:"desc";s:231:"This option gives you the ability to turn on/off the inline table editing controls in Firefox/Mozilla. According to the TinyMCE documentation, these controls are somewhat buggy and not redesignable, so they are disabled by default.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:22:"theme_advanced_disable";a:7:{s:4:"name";s:22:"theme_advanced_disable";s:4:"desc";s:111:"This option should contain a comma separated list of controls to disable from any toolbar row/panel in TinyMCE.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:0:"";s:7:"lexicon";N;s:4:"area";s:0:"";}s:19:"theme_advanced_path";a:7:{s:4:"name";s:19:"theme_advanced_path";s:4:"desc";s:331:"This option gives you the ability to enable/disable the element path. This option is only useful if the theme_advanced_statusbar_location option is set to "top" or "bottom". This option is set to "true" by default. Setting this option to "false" will effectively hide the path tool, though it still takes up room in the Status Bar.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:32:"theme_advanced_resize_horizontal";a:7:{s:4:"name";s:32:"theme_advanced_resize_horizontal";s:4:"desc";s:319:"This option gives you the ability to enable/disable the horizontal resizing. This option is only useful if the theme_advanced_statusbar_location option is set to "top" or "bottom" and when the theme_advanced_resizing is set to true. This option is set to true by default, allowing both resizing horizontal and vertical.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:23:"theme_advanced_resizing";a:7:{s:4:"name";s:23:"theme_advanced_resizing";s:4:"desc";s:216:"This option gives you the ability to enable/disable the resizing button. This option is only useful if the theme_advanced_statusbar_location option is set to "top" or "bottom". This option is set to false by default.";s:4:"type";s:13:"combo-boolean";s:7:"options";s:0:"";s:5:"value";b:1;s:7:"lexicon";N;s:4:"area";s:0:"";}s:33:"theme_advanced_statusbar_location";a:7:{s:4:"name";s:33:"theme_advanced_statusbar_location";s:4:"desc";s:257:"This option enables you to specify where the element statusbar with the path and resize tool should be located. This option can be set to "top" or "bottom". The default value is set to "top". This option can only be used when the theme is set to "advanced".";s:4:"type";s:4:"list";s:7:"options";a:2:{i:0;a:2:{s:5:"value";s:3:"top";s:4:"text";s:3:"Top";}i:1;a:2:{s:5:"value";s:6:"bottom";s:4:"text";s:6:"Bottom";}}s:5:"value";s:6:"bottom";s:7:"lexicon";N;s:4:"area";s:0:"";}s:28:"theme_advanced_toolbar_align";a:7:{s:4:"name";s:28:"theme_advanced_toolbar_align";s:4:"desc";s:187:"This option enables you to specify the alignment of the toolbar, this value can be "left", "right" or "center" (the default). This option can only be used when theme is set to "advanced".";s:4:"type";s:9:"textfield";s:7:"options";a:3:{i:0;a:2:{s:5:"value";s:6:"center";s:4:"text";s:6:"Center";}i:1;a:2:{s:5:"value";s:4:"left";s:4:"text";s:4:"Left";}i:2;a:2:{s:5:"value";s:5:"right";s:4:"text";s:5:"Right";}}s:5:"value";s:4:"left";s:7:"lexicon";N;s:4:"area";s:0:"";}s:31:"theme_advanced_toolbar_location";a:7:{s:4:"name";s:31:"theme_advanced_toolbar_location";s:4:"desc";s:191:"
This option enables you to specify where the toolbar should be located. This option can be set to "top" or "bottom" (the defualt). This option can only be used when theme is set to advanced.";s:4:"type";s:4:"list";s:7:"options";a:2:{i:0;a:2:{s:5:"value";s:3:"top";s:4:"text";s:3:"Top";}i:1;a:2:{s:5:"value";s:6:"bottom";s:4:"text";s:6:"Bottom";}}s:5:"value";s:3:"top";s:7:"lexicon";N;s:4:"area";s:0:"";}s:5:"width";a:7:{s:4:"name";s:5:"width";s:4:"desc";s:32:"The width of the TinyMCE editor.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:3:"95%";s:7:"lexicon";N;s:4:"area";s:0:"";}s:33:"template_selected_content_classes";a:7:{s:4:"name";s:33:"template_selected_content_classes";s:4:"desc";s:234:"Specify a list of CSS class names for the template plugin. They must be separated by spaces. Any template element with one of the specified CSS classes will have its content replaced by the selected editor content when first inserted.";s:4:"type";s:9:"textfield";s:7:"options";s:0:"";s:5:"value";s:0:"";s:7:"lexicon";N;s:4:"area";s:0:"";}}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    35 => 
    array (
      'id' => '35',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'TinyMCERTE',
      'description' => '',
      'editor_type' => '0',
      'category' => '33',
      'cache_type' => '0',
      'plugincode' => '/**
 * TinyMCE Rich Tech Editor
 *
 */
$corePath = $modx->getOption(\'tinymcerte.core_path\', null, $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components/tinymcerte/\');
/** @var TinyMCERTE $tinymcerte */
$tinymcerte = $modx->getService(
    \'tinymcerte\',
    \'TinyMCERTE\',
    $corePath . \'model/tinymcerte/\',
    array(
        \'core_path\' => $corePath
    )
);

$className = \'TinyMCERTE\' . $modx->event->name;
$modx->loadClass(\'TinyMCERTEPlugin\', $tinymcerte->getOption(\'modelPath\') . \'tinymcerte/events/\', true, true);
$modx->loadClass($className, $tinymcerte->getOption(\'modelPath\') . \'tinymcerte/events/\', true, true);
if (class_exists($className)) {
    /** @var TinyMCERTEPlugin $handler */
    $handler = new $className($modx, $scriptProperties);
    $handler->run();
}
return;',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    37 => 
    array (
      'id' => '37',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'VersionX',
      'description' => 'The plugin that enables VersionX of tracking your content.',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => '$corePath = $modx->getOption(\'versionx.core_path\',null,$modx->getOption(\'core_path\').\'components/versionx/\');
require_once $corePath.\'model/versionx.class.php\';
$modx->versionx = new VersionX($modx);

include $corePath . \'elements/plugins/versionx.plugin.php\';
return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    38 => 
    array (
      'id' => '38',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'fileTranslit',
      'description' => 'This plugin transliterates file names automatically on upload.',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => '/**
 * @author Anton Andersen <anton.a.andersen@gmail.com>
 *
 * This plugin transliterates filenames on upload via MODX filemanager.
 * It should be bent to the OnFileManagerUpload event.
 * Project page: https://github.com/TriAnMan/filetranslit
 */
$currentdoc = $modx->newObject(\'modResource\');
foreach ($files as &$file) {
	if ($file[\'error\'] == 0) {
		$newName = $currentdoc->cleanAlias($file[\'name\']);

		//file rename logic
		if ($file[\'name\'] !== $newName) {
			$arDirFiles = $source->getObjectsInContainer($directory);
			foreach ($arDirFiles as &$dirFile){
				if($dirFile[\'name\']===$newName){
					//delete file if there is one with new name
					$source->removeObject($directory . $newName);
				}
			}
			//transliterate uploaded file
			$source->renameObject($directory . $file[\'name\'], $newName);
		}
	}
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    51 => 
    array (
      'id' => '51',
      'source' => '0',
      'property_preprocess' => '0',
      'name' => 'msExtraAddressFields',
      'description' => '',
      'editor_type' => '0',
      'category' => '0',
      'cache_type' => '0',
      'plugincode' => 'switch ($modx->event->name) {
    case \'msOnBeforeCreateOrder\':
        $address = $msOrder->getOne(\'Address\');
        $properties = array();
        foreach ($_POST as $key => $value){
            if (strpos($key,\'extfld_\') !== false){
                $properties[$key] = htmlentities($value,ENT_COMPAT | ENT_HTML401,\'UTF-8\');
            }
        }
        if (count($properties) > 0){
            $address->set(\'properties\', json_encode($properties));    
        }
    break;
    
    case \'msOnManagerCustomCssJs\':
        if ($page != \'orders\') return;
	$modx->controller->addHtml("
            <script type=\'text/javascript\'>
                Ext.ComponentMgr.onAvailable(\'minishop2-window-order-update\', function(){
                	if (miniShop2.config[\'order_address_fields\'].in_array(\'properties\')){
                		if (this.record.addr_properties){
                		    var key;
                			for (key in this.record.addr_properties) {
                				this.fields.items[2].items.push(
                					{
                						xtype: \'displayfield\',
                						name: \'addr_properties_\'+key,
                						fieldLabel: _(\'ms2_properties_\'+key),
                						anchor: \'100%\',
                						style: \'border:1px solid #efefef;width:95%;padding:5px;\',
                						html: this.record.addr_properties[key]
                					}
                				);
                			}
                		}		
                	}
                });                
            </script>");
    break;
}',
      'locked' => '0',
      'properties' => 'a:0:{}',
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => '',
    ),
    52 => 
    array (
      'id' => '52',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'msofSystem',
      'description' => '',
      'editor_type' => '0',
      'category' => '50',
      'cache_type' => '0',
      'plugincode' => '/** @var modX $modx */
/** @var msOrderFiles $msof */

$path = MODX_CORE_PATH . \'components/msorderfiles/model/msorderfiles/\';
if (!is_object($modx->msorderfiles)) {
    $msof = $modx->getService(\'msorderfiles\', \'msOrderFiles\', $path);
} else {
    $msof = $modx->msorderfiles;
}
$className = \'msof\' . $modx->event->name;
$modx->loadClass(\'msofPlugin\', $msof->config[\'pluginsPath\'], true, true);
$modx->loadClass($className, $msof->config[\'pluginsPath\'], true, true);
if (class_exists($className)) {
    $handler = new $className($modx, $scriptProperties);
    $handler->run();
} else {
    // Удаляем событие у плагина, если такого класса не существует
    $event = $modx->getObject(\'modPluginEvent\', array(
        \'pluginid\' => $modx->event->plugin->get(\'id\'),
        \'event\' => $modx->event->name,
    ));
    if ($event instanceof modPluginEvent) {
        $event->remove();
    }
}
return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/msorderfiles/elements/plugins/plugin.system.php',
    ),
    47 => 
    array (
      'id' => '47',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'msOptionsPrice',
      'description' => '',
      'editor_type' => '0',
      'category' => '47',
      'cache_type' => '0',
      'plugincode' => '/** @var array $scriptProperties */
/** @var msoptionsprice $msoptionsprice */

$fqn = $modx->getOption(\'msoptionsprice_class\', null, \'msoptionsprice.msoptionsprice\', true);
$path = $modx->getOption(\'msoptionsprice_core_path\', null,
    $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components/msoptionsprice/\');
if (!$msoptionsprice = $modx->getService($fqn, \'\', $path . \'model/\',
    array(\'core_path\' => $path))
) {
    return false;
}

$className = \'msOptionsPrice\' . $modx->event->name;
$modx->loadClass(\'msOptionsPricePlugin\', $msoptionsprice->getOption(\'modelPath\') . \'msoptionsprice/systems/\', true,
    true);
$modx->loadClass($className, $msoptionsprice->getOption(\'modelPath\') . \'msoptionsprice/systems/\', true, true);
if (class_exists($className)) {
    /** @var msOptionsPricePlugin $handler */
    $handler = new $className($modx, $scriptProperties);
    $handler->run();
}
return;',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/msoptionsprice/elements/plugins/plugin.msoptionsprice.php',
    ),
    48 => 
    array (
      'id' => '48',
      'source' => '1',
      'property_preprocess' => '0',
      'name' => 'msOptionsPriceOnInit',
      'description' => '',
      'editor_type' => '0',
      'category' => '47',
      'cache_type' => '0',
      'plugincode' => 'if ($modx->event->name != \'OnMODXInit\') {
    return;
}

$classGallery = trim($this->xpdo->getOption(\'msoptionsprice_modification_gallery_class\', null,
    \'msProductFile\', true));

if (!empty($classGallery)) {
    $modx->loadClass($classGallery);
    $modx->map[$classGallery][\'composites\'][\'modificationImages\'] = array(
        \'class\'       => \'msopModificationImage\',
        \'local\'       => \'id\',
        \'foreign\'     => \'image\',
        \'cardinality\' => \'many\',
        \'owner\'       => \'local\',
    );
}',
      'locked' => '0',
      'properties' => NULL,
      'disabled' => '0',
      'moduleguid' => '',
      'static' => '0',
      'static_file' => 'core/components/msoptionsprice/elements/plugins/plugin.init.php',
    ),
  ),
  'policies' => 
  array (
    'modAccessContext' => 
    array (
      'mgr' => 
      array (
        0 => 
        array (
          'principal' => 1,
          'authority' => 0,
          'policy' => 
          array (
            'about' => true,
            'access_permissions' => true,
            'actions' => true,
            'change_password' => true,
            'change_profile' => true,
            'charsets' => true,
            'class_map' => true,
            'components' => true,
            'content_types' => true,
            'countries' => true,
            'create' => true,
            'credits' => true,
            'customize_forms' => true,
            'dashboards' => true,
            'database' => true,
            'database_truncate' => true,
            'delete_category' => true,
            'delete_chunk' => true,
            'delete_context' => true,
            'delete_document' => true,
            'delete_eventlog' => true,
            'delete_plugin' => true,
            'delete_propertyset' => true,
            'delete_role' => true,
            'delete_snippet' => true,
            'delete_template' => true,
            'delete_tv' => true,
            'delete_user' => true,
            'directory_chmod' => true,
            'directory_create' => true,
            'directory_list' => true,
            'directory_remove' => true,
            'directory_update' => true,
            'edit_category' => true,
            'edit_chunk' => true,
            'edit_context' => true,
            'edit_document' => true,
            'edit_locked' => true,
            'edit_plugin' => true,
            'edit_propertyset' => true,
            'edit_role' => true,
            'edit_snippet' => true,
            'edit_template' => true,
            'edit_tv' => true,
            'edit_user' => true,
            'element_tree' => true,
            'empty_cache' => true,
            'error_log_erase' => true,
            'error_log_view' => true,
            'events' => true,
            'export_static' => true,
            'file_create' => true,
            'file_list' => true,
            'file_manager' => true,
            'file_remove' => true,
            'file_tree' => true,
            'file_update' => true,
            'file_upload' => true,
            'file_unpack' => true,
            'file_view' => true,
            'flush_sessions' => true,
            'frames' => true,
            'help' => true,
            'home' => true,
            'import_static' => true,
            'languages' => true,
            'lexicons' => true,
            'list' => true,
            'load' => true,
            'logout' => true,
            'logs' => true,
            'menus' => true,
            'menu_reports' => true,
            'menu_security' => true,
            'menu_site' => true,
            'menu_support' => true,
            'menu_system' => true,
            'menu_tools' => true,
            'menu_user' => true,
            'messages' => true,
            'namespaces' => true,
            'new_category' => true,
            'new_chunk' => true,
            'new_context' => true,
            'new_document' => true,
            'new_document_in_root' => true,
            'new_plugin' => true,
            'new_propertyset' => true,
            'new_role' => true,
            'new_snippet' => true,
            'new_static_resource' => true,
            'new_symlink' => true,
            'new_template' => true,
            'new_tv' => true,
            'new_user' => true,
            'new_weblink' => true,
            'packages' => true,
            'policy_delete' => true,
            'policy_edit' => true,
            'policy_new' => true,
            'policy_save' => true,
            'policy_template_delete' => true,
            'policy_template_edit' => true,
            'policy_template_new' => true,
            'policy_template_save' => true,
            'policy_template_view' => true,
            'policy_view' => true,
            'property_sets' => true,
            'providers' => true,
            'publish_document' => true,
            'purge_deleted' => true,
            'remove' => true,
            'remove_locks' => true,
            'resource_duplicate' => true,
            'resourcegroup_delete' => true,
            'resourcegroup_edit' => true,
            'resourcegroup_new' => true,
            'resourcegroup_resource_edit' => true,
            'resourcegroup_resource_list' => true,
            'resourcegroup_save' => true,
            'resourcegroup_view' => true,
            'resource_quick_create' => true,
            'resource_quick_update' => true,
            'resource_tree' => true,
            'save' => true,
            'save_category' => true,
            'save_chunk' => true,
            'save_context' => true,
            'save_document' => true,
            'save_plugin' => true,
            'save_propertyset' => true,
            'save_role' => true,
            'save_snippet' => true,
            'save_template' => true,
            'save_tv' => true,
            'save_user' => true,
            'search' => true,
            'set_sudo' => true,
            'settings' => true,
            'sources' => true,
            'source_delete' => true,
            'source_edit' => true,
            'source_save' => true,
            'source_view' => true,
            'steal_locks' => true,
            'tree_show_element_ids' => true,
            'tree_show_resource_ids' => true,
            'undelete_document' => true,
            'unlock_element_properties' => true,
            'unpublish_document' => true,
            'usergroup_delete' => true,
            'usergroup_edit' => true,
            'usergroup_new' => true,
            'usergroup_save' => true,
            'usergroup_user_edit' => true,
            'usergroup_user_list' => true,
            'usergroup_view' => true,
            'view' => true,
            'view_category' => true,
            'view_chunk' => true,
            'view_context' => true,
            'view_document' => true,
            'view_element' => true,
            'view_eventlog' => true,
            'view_offline' => true,
            'view_plugin' => true,
            'view_propertyset' => true,
            'view_role' => true,
            'view_snippet' => true,
            'view_sysinfo' => true,
            'view_template' => true,
            'view_tv' => true,
            'view_unpublished' => true,
            'view_user' => true,
            'workspaces' => true,
            'formit' => true,
            'formit_encryptions' => true,
          ),
        ),
        1 => 
        array (
          'principal' => 1,
          'authority' => 9999,
          'policy' => 
          array (
            'mscategory_save' => true,
            'msproduct_save' => true,
            'msproduct_publish' => true,
            'msproduct_delete' => true,
            'msorder_save' => true,
            'msorder_view' => true,
            'msorder_list' => true,
            'mssetting_save' => true,
            'mssetting_view' => true,
            'mssetting_list' => true,
            'msproductfile_save' => true,
            'msproductfile_generate' => true,
            'msproductfile_list' => true,
            'formit' => true,
            'formit_encryptions' => false,
          ),
        ),
        2 => 
        array (
          'principal' => 1,
          'authority' => 9999,
          'policy' => 
          array (
            'msdiscount_save' => true,
            'msdiscount_view' => true,
            'formit' => true,
            'formit_encryptions' => false,
          ),
        ),
      ),
    ),
  ),
);